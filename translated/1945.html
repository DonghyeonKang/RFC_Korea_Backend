<body>
<span class="pre noprint docinfo">[<a href="https://www.rfc-editor.org" title="RFC Editor">RFC 홈</a>] [<a href="/rfc/rfc1945.html">텍스트|PDF|HTML</a>] [<a href="https://datatracker.ietf.org/doc/rfc1945" title="IETF Datatracker information for this document">추적기</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=1945&amp;submit=rfc" title="IPR disclosures related to this document">IPR</a>] [<a class="boldtext" href="/errata/rfc1945" target="_blank">오류</a>] [<a href="https://www.rfc-editor.org/info/rfc1945" title="Info page">정보 페이지</a>] </span><br /><span class="pre noprint docinfo"> </span><br /><span class="pre noprint docinfo">     정보</span><br /><span class="pre noprint docinfo"> <span style="color: #C00;">오류 존재</span></span><pre>네트워크 워킹 그룹 T. 버너스-리 의견 요청: 1945 MIT/LCS 범주: 정보 제공 R. Fielding UC Irvine H. Frystyk MIT/LCS 1996년 5월 <span class="h1">하이퍼텍스트 전송 프로토콜 -- HTTP/1.0</span>이 메모의 상태 이 메모는 인터넷 커뮤니티를 위한 정보를 제공합니다.  이 메모는 어떤 종류의 인터넷 표준도 지정하지 않습니다.  이 메모의 배포는 무제한입니다. IESG 참고: IESG는 이 프로토콜에 대해 우려를 가지고 있으며 이 문서가 비교적 빠른 시일 내에 표준 트랙 문서로 대체될 것으로 예상합니다. 개요 하이퍼텍스트 전송 프로토콜(HTTP)은 분산된 협업 하이퍼미디어 정보 시스템에 필요한 가벼움과 속도를 갖춘 애플리케이션 수준의 프로토콜입니다. 요청 방법(명령어)의 확장을 통해 이름 서버 및 분산 객체 관리 시스템과 같은 많은 작업에 사용할 수 있는 일반적인 상태 비저장 객체 지향 프로토콜입니다. HTTP의 특징은 전송되는 데이터와 독립적으로 시스템을 구축할 수 있는 데이터 표현 형식입니다. HTTP는 1990년부터 월드와이드웹 글로벌 정보 이니셔티브에서 사용되어 왔습니다. 이 사양은 "HTTP/1.0"이라고 하는 프로토콜의 일반적인 사용법을 반영합니다. 목차 <a href="#section-1">1</a>.  소개 .............................................. <a href="#page-4">4</a><a href="#section-1.1">1.1</a> 목적 .............................................. <a href="#page-4">4</a><a href="#section-1.2">1.2</a> 용어 .......................................... <a href="#page-4">4</a><a href="#section-1.3">1.3</a> 전반적인 운영 .................................... <a href="#page-6">6</a><a href="#section-1.4">1.4</a> HTTP와 MIME ........................................ <a href="#page-8">8</a><ahref="#section-2">2.  표기법 및 일반 문법 ................ <a href="#page-8">8</a><a href="#section-2.1">2.1</a> 증강 BNF ........................................ <a href="#page-8">8</a><a href="#section-2.2">2.2</a> 기본 규칙 .......................................... <a href="#page-10">10</a><ahref="#section-3">3</ahref="#section-3">.<ahref="#section-3"> 프로토콜 파라미터 ....................................... <a href="#page-12">12</a><span class="grey">버너스-리 등 정보 [1페이지]</span></ahref="#section-3"></ahref="#section-2"></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-2"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span> <a href="#section-3.1">3.1</a> HTTP 버전 ......................................... <a href="#page-12">12</a><a href="#section-3.2">3.2</a> 유니폼 리소스 식별자 ......................... <a href="#page-14">14</a><ahref="#section-3.2.1">3.2.1 일반 구문 ................................ <a href="#page-14">14</a><ahref="#section-3.2.2">3.2.2 http URL ...................................... <a href="#page-15">15</a><a href="#section-3.3">3.3</a> 날짜/시간 형식 .................................... <a href="#page-15">15</a><a href="#section-3.4">3.4</a> 문자 집합 ....................................... <a href="#page-17">17</a><a href="#section-3.5">3.5</a> 콘텐츠 코딩 ...................................... <a href="#page-18">18</a><a href="#section-3.6">3.6</a> 미디어 유형 .......................................... <a href="#page-19">19</a><ahref="#section-3.6.1">3.6.1 표준화 및 텍스트 기본값 ............ <a href="#page-19">19</a><ahref="#section-3.6.2">3.6.2 멀티파트 유형 ............................... <a href="#page-20">20</a><a href="#section-3.7">3.7</a> 제품 토큰 ....................................... <a href="#page-20">20</a><ahref="#section-4">4</ahref="#section-4"></ahref="#section-3.6.2">.<ahref="#section-3.6.2"><ahref="#section-4"> HTTP 메시지 .............................................. <a href="#page-21">21</a><a href="#section-4.1">4.1</a> 메시지 유형 ........................................ <a href="#page-21">21</a><a href="#section-4.2">4.2</a> 메시지 헤더 ...................................... <a href="#page-22">22</a><a href="#section-4.3">4.3</a> 일반 헤더 필드 ................................ <a href="#page-23">23</a><ahref="#section-5">5</ahref="#section-5">.<ahref="#section-5"> 요청 ................................................... <a href="#page-23">23</a><a href="#section-5.1">5.1</a> 요청-라인 ......................................... <a href="#page-23">23</a><ahref="#section-5.1.1">5.1.1 방법 ........................................ <a href="#page-24">24</a><ahref="#section-5.1.2">5.1.2 요청-URI ................................... <a href="#page-24">24</a><a href="#section-5.2">5.2</a> 요청 헤더 필드 ................................ <a href="#page-25">25</a><ahref="#section-6">6.  응답 .................................................. <a href="#page-25">25</a><a href="#section-6.1">6.1</a> Status-Line .......................................... <a href="#page-26">26</a><ahref="#section-6.1.1">6.1.1 상태 코드 및 이유 문구 ................. <a href="#page-26">26</a><a href="#section-6.2">6.2</a> 응답 헤더 필드 ............................... <a href="#page-28">28</a><ahref="#section-7">7.  엔티티 .................................................... <a href="#page-28">28</a><a href="#section-7.1">7.1</a> 엔티티 헤더 필드 ................................. <a href="#page-29">29</a><a href="#section-7.2">7.2</a> 엔티티 본문 .......................................... <a href="#page-29">29</a><ahref="#section-7.2.1">7.2.1 유형 .......................................... <a href="#page-29">29</a><ahref="#section-7.2.2">7.2.2 길이 ........................................ <a href="#page-30">30</a><ahref="#section-8">8.  메서드 정의 ........................................ <a href="#page-30">30</a><a href="#section-8.1">8.1</a> GET .................................................. <a href="#page-31">31</a><a href="#section-8.2">8.2</a> HEAD ................................................. <a href="#page-31">31</a><a href="#section-8.3">8.3</a> POST ................................................. <a href="#page-31">31</a><ahref="#section-9">9.  상태 코드 정의 ................................... <a href="#page-32">32</a><a href="#section-9.1">9.1</a> 정보 1xx .................................... <a href="#page-32">32</a><a href="#section-9.2">9.2</a> 성공 2xx ....................................... <a href="#page-32">32</a><a href="#section-9.3">9.3</a> 리디렉션 3xx ...................................... <a href="#page-34">34</a><a href="#section-9.4">9.4</a> 클라이언트 오류 4xx ..................................... <a href="#page-35">35</a><a href="#section-9.5">9.5</a> 서버 오류 5xx ..................................... <a href="#page-37">37</a><ahref="#section-10">10. 헤더 필드 정의 .................................. <a href="#page-37">37</a><a href="#section-10.1">10.1</a> 허용 ............................................... <a href="#page-38">38</a><a href="#section-10.2">10.2</a> 권한 부여 ....................................... <a href="#page-38">38</a><a href="#section-10.3">10.3</a> 콘텐츠 인코딩 .................................... <a href="#page-39">39</a><a href="#section-10.4">10.4</a> 콘텐츠 길이 ...................................... <a href="#page-39">39</a><a href="#section-10.5">10.5</a> Content-Type ........................................ <a href="#page-40">40</a><a href="#section-10.6">10.6</a> 날짜 ................................................ <a href="#page-40">40</a><a href="#section-10.7">10.7</a> 만료 ............................................. <a href="#page-41">41</a><a href="#section-10.8">10.8</a> 출처 ................................................ <a href="#page-42">42</a><span class="grey">버너스 리 등 정보 [2페이지]</span></ahref="#section-10"></ahref="#section-9"></ahref="#section-8"></ahref="#section-7.2.2"></ahref="#section-7.2.1"></ahref="#section-7"></ahref="#section-6.1.1"></ahref="#section-6"></ahref="#section-5.1.2"></ahref="#section-5.1.1"></ahref="#section-5"></ahref="#section-4"></ahref="#section-3.6.2"></ahref="#section-3.6.1"></ahref="#section-3.2.2"></ahref="#section-3.2.1"></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-3"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span> <a href="#section-10.9">10.9</a> If-Modified-Since ................................... <a href="#page-42">42</a><a href="#section-10.10">10.10</a> 마지막 수정 ....................................... <a href="#page-43">43</a><a href="#section-10.11">10.11</a> 위치 ............................................ <a href="#page-44">44</a><a href="#section-10.12">10.12</a> Pragma .............................................. <a href="#page-44">44</a><a href="#section-10.13">10.13</a> 리퍼러 ............................................. <a href="#page-44">44</a><a href="#section-10.14">10.14</a> 서버 .............................................. <a href="#page-45">45</a><a href="#section-10.15">10.15</a> 사용자-에이전트 .......................................... <a href="#page-46">46</a><a href="#section-10.16">10.16</a> WWW-Authenticate .................................... <a href="#page-46">46</a><ahref="#section-11">11. 액세스 인증 ..................................... <a href="#page-47">47</a><a href="#section-11.1">11.1</a> 기본 인증 체계 ......................... <a href="#page-48">48</a><ahref="#section-12">12. 보안 고려 사항 ................................... <a href="#page-49">49</a><a href="#section-12.1">12.1</a> 클라이언트 인증 ........................... <a href="#page-49">49</a><a href="#section-12.2">12.2</a> 안전한 방법 ........................................ <a href="#page-49">49</a><a href="#section-12.3">12.3</a> 서버 로그 정보 남용 ..................... <a href="#page-50">50</a><a href="#section-12.4">12.4</a> 민감한 정보의 전송 ................... <a href="#page-50">50</a><a href="#section-12.5">12.5</a> 파일 및 경로 이름을 기반으로 한 공격 ................ <a href="#page-51">51</a><ahref="#section-13">13</ahref="#section-13">.<ahref="#section-13">감사의 말 ........................................... <a href="#page-51">51</a><ahref="#section-14">14. 참조 ................................................ <a href="#page-52">52</a><ahref="#section-15">15. 저자 주소 ........................................ <a href="#page-54">54</a><ahref="#appendix-a">부록 A.   인터넷 미디어 유형 메시지/http ................ <a href="#page-55">55</a>부록<ahref="#appendix-b">B.   허용 애플리케이션 ........................... <a href="#page-55">55</a>부록<ahref="#appendix-c">C.   MIME과의 관계 ............................ <a href="#page-56">56</a><a href="#appendix-C.1">C.1</a> 표준 포맷으로의 변환 ......................... <a href="#page-56">56</a><a href="#appendix-C.2">C.2</a> 날짜 형식의 변환 ........................... <a href="#page-57">57</a><a href="#appendix-C.3">C.3</a> 콘텐츠 인코딩 도입 ..................... <a href="#page-57">57</a><a href="#appendix-C.4">C.4</a> 콘텐츠 전송 인코딩 없음 ......................... <a href="#page-57">57</a><a href="#appendix-C.5">C.5</a> 멀티파트 본문 부분의 HTTP 헤더 필드 ........... <a href="#page-57">57</a><ahref="#appendix-d">부록 D</ahref="#appendix-d">.<ahref="#appendix-d">  추가 기능 ............................. <a href="#page-57">57</a><a href="#appendix-D.1">D.1</a> 추가 요청 방법 ........................... <a href="#page-58">58</a><ahref="#appendix-d.1.1">D.1.1 PUT ........................................... <a href="#page-58">58</a><ahref="#appendix-d.1.2">D.1.2 DELETE ........................................ <a href="#page-58">58</a><ahref="#appendix-d.1.3">D.1.3 링크 .......................................... <a href="#page-58">58</a><ahref="#appendix-d.1.4">D.1.4 링크 해제 ........................................ <a href="#page-58">58</a><a href="#appendix-D.2">D.2</a> 추가 헤더 필드 정의 .................. <a href="#page-58">58</a><ahref="#appendix-d.2.1">D.2.1 Accept ........................................ <a href="#page-58">58</a><ahref="#appendix-d.2.2">D.2.2 허용-문자세트 ................................ <a href="#page-59">59</a><ahref="#appendix-d.2.3">D.2.3 Accept-Encoding ............................... <a href="#page-59">59</a><ahref="#appendix-d.2.4">D.2.4 Accept-Language ............................... <a href="#page-59">59</a><ahref="#appendix-d.2.5">D.2.5 콘텐츠-언어 .............................. <a href="#page-59">59</a><ahref="#appendix-d.2.6">D.2.6 링크 .......................................... <a href="#page-59">59</a><ahref="#appendix-d.2.7">D.2.7 MIME-Version .................................. <a href="#page-59">59</a><ahref="#appendix-d.2.8">D.2.8 재시도-후 ................................... <a href="#page-60">60</a><ahref="#appendix-d.2.9">D.2.9 제목 ......................................... <a href="#page-60">60</a><ahref="#appendix-d.2.10">D.2.10 URI ........................................... <a href="#page-60">60</a><span class="grey">버너스-리 등 정보 [페이지 3]</span></ahref="#appendix-d.2.10"></ahref="#appendix-d.2.9"></ahref="#appendix-d.2.8"></ahref="#appendix-d.2.7"></ahref="#appendix-d.2.6"></ahref="#appendix-d.2.5"></ahref="#appendix-d.2.4"></ahref="#appendix-d.2.3"></ahref="#appendix-d.2.2"></ahref="#appendix-d.2.1"></ahref="#appendix-d.1.4"></ahref="#appendix-d.1.3"></ahref="#appendix-d.1.2"></ahref="#appendix-d.1.1"></ahref="#appendix-d"></ahref="#appendix-c"></ahref="#appendix-b"></ahref="#appendix-a"></ahref="#section-15"></ahref="#section-14"></ahref="#section-13"></ahref="#section-12"></ahref="#section-11"></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-4"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><span class="h2"><a class="selflink" href="#section-1" id="section-1">1</a>.  서론</span><span class="h3"><a class="selflink" href="#section-1.1" id="section-1.1">1.1</a> 목적</span>하이퍼텍스트 전송 프로토콜(HTTP)은 분산된 협업 하이퍼미디어 정보 시스템에 필요한 가벼움과 속도를 갖춘 애플리케이션 수준의 프로토콜입니다. HTTP는 1990년부터 월드와이드웹 글로벌 정보 이니셔티브에서 사용되어 왔습니다. 이 사양은 "HTTP/1.0"이라고도 불리는 프로토콜의 일반적인 사용법을 반영합니다. 이 사양은 대부분의 HTTP/1.0 클라이언트와 서버에서 일관되게 구현되는 기능에 대해 설명합니다. 사양은 두 섹션으로 나뉩니다. 일반적으로 구현이 일관된 HTTP의 기능들은 이 문서의 본문에 설명되어 있습니다. 구현이 거의 없거나 일관성이 없는 기능은 <a href="#appendix-D">부록 D에</a> 나열되어 있습니다. 실제 정보 시스템에는 검색, 프론트엔드 업데이트, 주석 등 단순한 검색보다 더 많은 기능이 필요합니다. HTTP는 요청의 목적을 나타내는 데 사용할 수 있는 개방형 메서드 집합을 허용합니다. 이는 메서드가 적용될 리소스를 표시하기 위해 위치(URL)<a href="#ref-4" title='"Uniform Resource Locators (URL)"'>[4</a>] 또는 이름(URN)<a href="#ref-16" title='"Functional Requirements for Uniform Resource Names"'>[16</a>]으로 통일 리소스 식별자(URI)<a href="#ref-2" title='"Universal Resource Identifiers in WWW: A Unifying Syntax for the Expression of Names and Addresses of Objects on the Network as used in the World-Wide Web"'>[2</a>]가 제공하는 참조 규율을 기반으로 합니다. 메시지는 인터넷 메일<a href="#ref-7" title='"Standard for the Format of ARPA Internet Text Messages"'>[7</a>] 및 다목적 인터넷 메일 확장(MIME)<a href="#ref-5" title='"MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies"'>[5</a>]에서 사용하는 것과 유사한 형식으로 전달됩니다. HTTP는 사용자 에이전트와 프록시/게이트웨이 간의 통신을 위한 일반 프로토콜로도 사용되며, SMTP<a href="#ref-12" title='"Simple Mail Transfer Protocol."'>[12</a>], NNTP[<a href="#ref-11" title='"Network News Transfer Protocol: A Proposed Standard for the Stream-Based Transmission of News"'>11</a>], FTP<a href="#ref-14" title='"File Transfer Protocol (FTP)"'>[14</a>], Gopher<a href="#ref-1" title='"The Internet Gopher Protocol: A Distributed Document Search and Retrieval Protocol"'>[1</a>], WAIS<a href="#ref-8" title='"WAIS Interface Protocol Prototype Functional Specification."'>[8</a>] 등 다른 인터넷 프로토콜과도 통신할 수 있어 다양한 애플리케이션에서 제공되는 리소스에 대한 기본적인 하이퍼미디어 접근을 지원하고 사용자 에이전트의 구현이 간편화되도록 해줍니다<span class="h3"><a class="selflink" href="#section-1.2" id="section-1.2">.2</a> 용어</span>본 명세서에서는 HTTP 통신의 참여자와 객체가 수행하는 역할을 지칭하기 위해 여러 용어를 사용합니다. 연결 통신을 목적으로 두 애플리케이션 프로그램 사이에 설정된 전송 계층 가상 회로 메시지 <a href="#section-4">섹션 4에</a> 정의된 구문과 일치하는 구조화된 옥텟 시퀀스로 구성되고 연결을 통해 전송되는 HTTP 통신의 기본 단위.<span class="grey">Berners-Lee 외 정보 [4페이지]</span>.</pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-5"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>요청 HTTP 요청 메시지( <a href="#section-5">섹션 5에</a> 정의됨). 응답 HTTP 응답 메시지( <a href="#section-6">섹션 6에</a> 정의됨). 자원 URI로 식별할 수 있는 네트워크 데이터 개체 또는 서비스<a href="#section-3.2">(섹션 3.2)</a>. 엔티티 요청 또는 응답 메시지 내에 포함될 수 있는 데이터 자원의 특정 표현 또는 표현, 또는 서비스 자원의 응답입니다. 엔티티는 엔티티 헤더 형태의 메타정보와 엔티티 본문 형태의 콘텐츠로 구성됩니다. 클라이언트 요청을 전송하기 위해 연결을 설정하는 애플리케이션 프로그램입니다. 사용자 에이전트 요청을 시작하는 클라이언트입니다. 브라우저, 편집기, 스파이더(웹 탐색 로봇) 또는 기타 최종 사용자 도구인 경우가 많습니다. 서버 응답을 다시 보내 요청을 서비스하기 위해 연결을 수락하는 애플리케이션 프로그램 원본 서버 특정 리소스가 상주하거나 생성될 서버입니다. 프록시 다른 클라이언트를 대신하여 요청을 수행할 목적으로 서버와 클라이언트 역할을 모두 하는 중개 프로그램입니다. 요청은 내부적으로 처리되거나 가능한 경우 번역을 거쳐 다른 서버로 전달됩니다. 프록시는 요청 메시지를 해석하고 필요한 경우<span class="grey">버너스-리 등 정보 [5페이지]</span> 이전에 요청 메시지를 다시 작성해야 합니다.</pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-6"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>포워딩. 프록시는 종종 네트워크 방화벽을 통한 클라이언트 측 포털로 사용되며 사용자 에이전트가 구현하지 않은 프로토콜을 통해 요청을 처리하는 도우미 애플리케이션으로 사용됩니다. 게이트웨이 다른 서버의 중개자 역할을 하는 서버입니다. 프록시와 달리 게이트웨이는 요청된 리소스의 원본 서버인 것처럼 요청을 수신하므로 요청 클라이언트는 자신이 게이트웨이와 통신하고 있다는 사실을 인지하지 못할 수 있습니다. 게이트웨이는 종종 네트워크 방화벽을 통한 서버 측 포털로 사용되거나 비 HTTP 시스템에 저장된 리소스에 액세스하기 위한 프로토콜 변환기로 사용됩니다. 터널 터널은 두 연결 사이의 블라인드 릴레이 역할을 하는 중개 프로그램입니다. 터널이 활성화되면 터널은 HTTP 요청에 의해 시작되었을지라도 HTTP 통신의 당사자로 간주되지 않습니다. 터널은 릴레이된 연결의 양쪽 끝이 닫히면 더 이상 존재하지 않습니다. 터널은 포털이 필요하고 중개자가 중계된 통신을 해석할 수 없거나 해석해서는 안 될 때 사용됩니다. 캐시 응답 메시지의 프로그램 로컬 저장소 및 메시지 저장, 검색, 삭제를 제어하는 하위 시스템. 캐시는 향후 동일한 요청에 대한 응답 시간 및 네트워크 대역폭 소비를 줄이기 위해 캐시 가능한 응답을 저장합니다. 모든 클라이언트 또는 서버는 캐시를 포함할 수 있지만, 서버가 터널 역할을 하는 동안에는 캐시를 사용할 수 없습니다. 특정 프로그램은 클라이언트와 서버 역할을 모두 수행할 수 있으며, 이러한 용어의 사용은 프로그램의 일반적인 기능보다는 특정 연결에 대해 프로그램이 수행하는 역할만을 나타냅니다. 마찬가지로 모든 서버는 오리진 서버, 프록시, 게이트웨이 또는 터널 역할을 할 수 있으며 각 요청의 성격에 따라 동작을 전환합니다.<span class="h3"><a class="selflink" href="#section-1.3" id="section-1.3">1.3</a> 전반적인 작동</span>HTTP 프로토콜은 요청/응답 패러다임에 기반합니다. 클라이언트는 서버와 연결을 설정하고 요청 방법, URI, 프로토콜 버전과 함께 요청 수정자, 클라이언트 정보, 가능한 본문 콘텐츠가 포함된 MIME 형식의 메시지를 서버에 보냅니다. 서버는<span class="grey">버너스-리 등 정보 [페이지 6</span>]로 응답합니다.</pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-7"></span>
메시지의 프로토콜 버전과 성공 또는 오류 코드, 서버 정보, 엔티티 메타정보, 가능한 본문 내용을 포함하는 MIME 형식의 메시지가 포함된<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>상태 라인. 대부분의 HTTP 통신은 사용자 에이전트에 의해 시작되며 일부 원본 서버의 자원에 적용하기 위한 요청으로 구성됩니다. 가장 간단한 경우에는 사용자 에이전트(UA)와 원본 서버(O) 간의 단일 연결(v)을 통해 이루어질 수 있습니다. 요청 체인 ------------------------&gt; UA -------------------v------------------- O &lt;----------------------- 응답 체인 요청/응답 체인에 하나 이상의 중개자가 있는 경우 더 복잡한 상황이 발생할 수 있습니다. 중개자에는 프록시, 게이트웨이, 터널의 세 가지 일반적인 형태가 있습니다. 프록시는 전달 에이전트로, 절대 형식의 URI 요청을 수신하여 메시지의 전체 또는 일부를 재작성하고 재포맷된 요청을 URI로 식별된 서버로 전달합니다. 게이트웨이는 수신 에이전트로서 다른 서버 위에 있는 레이어 역할을 하며 필요한 경우 요청을 기본 서버의 프로토콜로 변환합니다. 터널은 메시지를 변경하지 않고 두 연결 사이의 중계 지점 역할을 하며, 터널은 중개자가 메시지 내용을 이해할 수 없는 경우에도 통신이 방화벽과 같은 중개자를 통과해야 할 때 사용됩니다. 요청 체인 --------------------------------------&gt; UA -----v----- A -----v----- B -----v----- C -----v----- O &lt;------------------------------------- 응답 체인 위 그림은 사용자 에이전트와 원본 서버 사이의 3개의 중개자(A, B, C)를 보여줍니다. 전체 체인을 이동하는 요청 또는 응답 메시지는 4개의 개별 연결을 통과해야 합니다. 이 구분이 중요한 이유는 일부 HTTP 통신 옵션은 터널이 아닌 가장 가까운 이웃과의 연결에만 적용되거나, 체인의 엔드포인트에만 적용되거나, 체인의 모든 연결에 적용될 수 있기 때문입니다. 다이어그램은 선형적이지만 각 참여자는 여러 개의 동시 통신에 참여할 수 있습니다. 예를 들어, B는 A 이외의 많은 클라이언트로부터 요청을 받거나 A의 요청을 처리하는 동시에 C 이외의 서버로 요청을 전달할 수 있습니다. 터널 역할을 하지 않는 통신의 모든 당사자는 요청을 처리하기 위해 내부 캐시를 사용할 수 있습니다. 캐시의 효과는 체인의 참여자 중 한 명이 해당 요청에 해당하는 캐시된 응답을 가지고 있는 경우 요청/응답 체인이 단축된다는 것입니다. 다음은 B에<span class="grey">버너스-리 등 정보 [7페이지</span>]가 있는 경우의 결과 체인을 보여줍니다.</pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-8"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>UA 또는 A에 의해 캐시되지 않은 요청에 대해 O(C 경유)에서 이전 응답의 복사본 캐시 요청 체인 ----------&gt; UA -----v----- A -----v----- B - - - - - C - - - - - O &lt;--------- 응답 체인 모든 응답이 캐시 가능하지는 않으며 일부 요청에는 캐시 동작에 특별한 요구사항을 적용하는 수정자가 포함될 수 있습니다. 일부 HTTP/1.0 애플리케이션은 휴리스틱을 사용하여 "캐싱 가능한" 응답인지 아닌지를 설명하지만 이러한 규칙은 표준화되어 있지 않습니다. 인터넷에서 HTTP 통신은 일반적으로 TCP/IP 연결을 통해 이루어집니다. 기본 포트는 TCP 80<a href="#ref-15" title='"Assigned Numbers"'>[15</a>]이지만 다른 포트를 사용할 수도 있습니다. 그렇다고 해서 인터넷이나 다른 네트워크의 다른 프로토콜 위에 HTTP가 구현되는 것을 배제하지는 않습니다. HTTP는 신뢰할 수 있는 전송을 전제로 할 뿐이며, 그러한 보장을 제공하는 모든 프로토콜을 사용할 수 있으며, HTTP/1.0 요청 및 응답 구조를 해당 프로토콜의 전송 데이터 단위로 매핑하는 것은 이 사양의 범위를 벗어납니다. 실험적인 애플리케이션을 제외하고, 현재 관행에서는 각 요청 전에 클라이언트가 연결을 설정하고 응답을 보낸 후 서버가 연결을 닫도록 요구하고 있습니다. 클라이언트와 서버 모두 사용자 작업, 자동 시간 초과 또는 프로그램 오류로 인해 어느 한쪽이 연결을 조기에 종료할 수 있음을 인지하고 예측 가능한 방식으로 연결을 종료해야 합니다. 어떤 경우든, 어느 한쪽 또는 양쪽 당사자가 연결을 종료하면 상태와 관계없이 항상 현재 요청이 종료됩니다.<span class="h3"><a class="selflink" href="#section-1.4" id="section-1.4">1.4</a> HTTP와 MIME</span>HTTP/1.0은 <a href="./rfc1521">RFC 1521</a><a href="#ref-5" title='"MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies"'>[5</a>]에 정의된 대로 MIME에 정의된 많은 구성을 사용합니다. <a href="#appendix-C">부록 C에서는</a> HTTP의 컨텍스트가 인터넷 메일에서 일반적으로 볼 수 있는 것과 다른 인터넷 미디어 타입의 사용을 허용하는 방식과 이러한 차이에 대한 근거를 설명합니다<span class="h2">.</span><span class="h2">표기법 및 일반 문법</span><span class="h3"><a class="selflink" href="#section-2.1" id="section-2.1">2.1</a> 증강 BNF</span>본 문서에 명시된 모든 메커니즘은 산문과 <a href="./rfc822">RFC 822</a><a href="#ref-7" title='"Standard for the Format of ARPA Internet Text Messages"'>[7</a>]에서 사용하는 것과 유사한 증강 백쿠스-나우어 형식(BNF)으로 설명되어 있습니다. 구현자는 이 사양을 이해하려면 표기법에 익숙해야 합니다. 증강된 BNF에는 다음과 같은 구성이 포함됩니다:<span class="grey">Berners-Lee 등 정보 [페이지 8]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-9"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>이름 = 정의 규칙의 이름은 단순히 이름 자체(둘러싸는 "&lt;" 및 "&gt;" 없이)이며 정의와 같은 문자 "="로 구분됩니다. 공백은 두 줄 이상에 걸쳐 있는 규칙 정의를 나타낼 때 연속 줄의 들여쓰기가 사용된다는 점에서만 중요합니다. SP, LWS, HT, CRLF, DIGIT, ALPHA 등과 같은 특정 기본 규칙은 대문자로 되어 있습니다. 대괄호는 규칙 이름을 쉽게 구분할 수 있는 경우 정의 내에서 사용됩니다. "리터럴" 따옴표는 리터럴 텍스트를 둘러싸고 있습니다. 달리 명시되지 않는 한 텍스트는 대소문자를 구분하지 않습니다. 규칙1 | 규칙2 막대("I")로 구분된 요소는 대체 요소입니다(예: "yes | no"는 예 또는 아니오를 허용합니다.) 괄호로 묶인 요소는 단일 요소로 취급됩니다(rule1 rule2). 따라서 "(elem (foo | bar) elem)"은 토큰 시퀀스 "elem foo elem" 및 "elem bar elem"을 허용합니다. *규칙 요소 앞의 "*" 문자는 반복을 나타냅니다. 전체 형식은 "&lt;n&gt;*&lt;m&gt;엘리먼트"로, 최소 &lt;n&gt;에서 최대 &lt;m&gt;개의 엘리먼트가 있음을 나타냅니다. 기본값은 0과 무한대이므로 "*(요소)"는 0을 포함한 모든 수를 허용하고, "1*요소"는 최소 1개가 필요하며, "1*2요소"는 1개 또는 2개가 허용됩니다.<a id="ref-rule">[규칙</a>] 대괄호는 선택 요소를 둘러싸고, "[foo bar]"는 "*1(foo bar)"와 동일합니다. N 규칙 특정 반복: "&lt;n&gt;(요소)"는 "&lt;n&gt;*&lt;n&gt;(요소)", 즉 정확히 &lt;n&gt;번의 (요소) 발생과 동일합니다. 따라서 2DIGIT은 2자리 숫자이고 3ALPHA는 세 개의 알파벳 문자로 이루어진 문자열입니다.<span class="grey">버너스 리 외 정보 [9페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-10"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>#규칙 "#" 구문은 "*"와 유사하게 요소 목록을 정의하기 위해 정의됩니다. 전체 형식은 "&lt;n&gt;#&lt;m&gt;요소"로, 하나 이상의 쉼표(",")와 선택적 선형 공백(LWS)으로 구분된 최소 &lt;n&gt;에서 최대 &lt;m&gt;개의 요소를 나타냅니다. 이렇게 하면 일반적인 형태의 목록이 매우 쉬워집니다. "( *LWS 요소 *( *LWS "," *LWS 요소 ))"와 같은 규칙은 "1#element"로 표시할 수 있습니다. 이 구문이 사용되는 모든 곳에서 널 요소는 허용되지만 존재하는 요소의 수에 기여하지 않습니다. 즉, "(요소), , (요소)"는 허용되지만 두 개의 요소로만 계산됩니다. 따라서 요소가 하나 이상 필요한 경우 null이 아닌 요소가 하나 이상 있어야 합니다. 기본값은 0과 무한대이므로 "#(엘리먼트)"는 0을 포함한 모든 숫자를 허용하고 "1#엘먼트"는 하나 이상, "1#2엘먼트"는 하나 또는 둘을 허용합니다. 주석 규칙 텍스트 오른쪽에서 일정 거리를 두고 세미콜론을 사용하면 줄 끝에서 계속되는 주석이 시작됩니다. 이것은 사양과 병행하여 유용한 메모를 포함하는 간단한 방법입니다. 암시 *LWS 이 사양에서 설명하는 문법은 단어 기반입니다. 달리 명시된 경우를 제외하고, 인접한 두 단어(토큰 또는 따옴표로 묶인 문자열) 사이, 인접한 토큰과 구분 기호(tspecial) 사이에 필드의 해석을 변경하지 않고 선형 공백(LWS)을 포함할 수 있습니다. 그렇지 않으면 하나의 토큰으로 해석되므로 두 토큰 사이에 적어도 하나의 구분 기호(tspecial)가 존재해야 합니다. 그러나 공통 형식을 벗어나는 것을 허용하지 않는 구현이 일부 존재하므로 애플리케이션은 HTTP 구문을 생성할 때 "공통 형식"을 따라야 합니다.<span class="h3"><a class="selflink" href="#section-2.2" id="section-2.2">2.2</a> 기본 규칙</span>이 명세서 전체에서 기본 구문 분석 구문을 설명하기 위해 다음 규칙이 사용됩니다. US-ASCII 코딩 문자 집합은<a href="#ref-17" title="ANSI">[17</a>]에 정의되어 있습니다. OCTET = &lt;모든 8비트 데이터 시퀀스&gt; CHAR = &lt;모든 US-ASCII 문자 (옥텟 0 - 127)&gt; UPALPHA = &lt;모든 US-ASCII 대문자 "A"..."Z"&gt; LOALPHA = &lt;모든 US-ASCII 소문자 "a"..."z"&gt;<span class="grey">Berners-Lee 외 정보 [10페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-11"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>ALPHA = 위팔파 | 아래팔파 숫자 = &lt;모든 US-ASCII 숫자 "0"."9"&gt; CTL = &lt;모든 US-ASCII 제어 문자(0 - 31 옥텟) 및 DEL (127)&gt; CR = &lt;US-ASCII CR, 캐리지 리턴 (13)&gt; LF = &lt;US-ASCII LF, 라인 피드 (10)&gt; SP = &lt;US-ASCII SP, 공백 (32)&gt; HT = &lt;US-ASCII HT, 가로 탭 (9)&gt; &lt;"&gt; = &lt;US-ASCII 큰따옴표 (34)&gt; HTTP/1.0은 엔티티-바디를 제외한 모든 프로토콜 요소의 줄 끝 마커로 옥텟 시퀀스 CR LF를 정의합니다(허용되는 애플리케이션에 대해서는 <a href="#appendix-B">부록 B</a> 참조). 엔티티-바디 내의 줄 끝 마커는 <a href="#section-3.6">섹션 3.6에</a> 설명된 대로 관련 미디어 유형에 따라 정의됩니다. 각 연속 줄이 공백 또는 가로 탭으로 시작하면 CRLF = CR LF HTTP/1.0 헤더는 여러 줄로 접힐 수 있습니다. 접힘을 포함한 모든 선형 공백은 SP와 동일한 의미를 갖습니다. LWS = [CRLF] 1*( SP | HT ) 그러나 일부 애플리케이션에서는 헤더 줄 접힘이 예상되지 않으며 HTTP/1.0 애플리케이션에서 생성해서는 안 됩니다. TEXT 규칙은 메시지 파서가 해석하지 않는 설명 필드 내용 및 값에만 사용됩니다. TEXT = &lt;CTL을 제외한 모든 옥텟, 단 LWS 포함&gt; 헤더 필드 TEXT에 US-ASCII 문자 집합 이외의 옥텟이 포함된 경우 수신자는 이를 ISO-8859-1 문자를 나타내는 것으로 간주할 수 있습니다.
 16진수 문자는 여러 프로토콜 요소에 사용됩니다. HEX = "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f" | DIGIT 많은 HTTP/1.0 헤더 필드 값이 LWS 또는 특수 문자로 구분된 단어로 구성됩니다. 이러한 특수 문자는 매개변수 값 내에서 사용하려면 따옴표로 묶인 문자열 안에 있어야 합니다. 단어 = 토큰 | 따옴표 문자열<span class="grey">Berners-Lee 외 정보 [11페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-12"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>토큰 = 1*&lt;CTL 또는 tspecial을 제외한 모든 문자&gt; tspecials = "(" | ")" | "&lt;" | "&gt;" | "@" | "," | ";" | ":" | "\" | &lt;"&gt; | "/" | "[" | "]" | "?" | "=" | "{" | "}" | SP | HT 댓글 텍스트를 괄호로 둘러싸면 일부 HTTP 헤더 필드에 댓글이 포함될 수 있습니다. 댓글은 필드 값 정의의 일부로 "댓글"이 포함된 필드에서만 허용됩니다. 다른 모든 필드에서는 괄호가 필드 값의 일부로 간주됩니다. comment = "(" *( ctext | comment ) ")" ctext = &lt; "(" 및 ")"를 제외한 모든 텍스트&gt; 텍스트 문자열은 큰따옴표를 사용하여 따옴표로 묶으면 단일 단어로 파싱됩니다.
 quoted-string = ( &lt;"&gt; *(qdtext) &lt;"&gt; ) qdtext = &lt;&lt;"&gt; 및 CTL을 제외한 모든 문자, 단 LWS 포함&gt; 백슬래시("\") 문자를 사용한 단일 문자 인용은 HTTP/1.0에서 허용되지 않습니다.<span class="h2"><a class="selflink" href="#section-3" id="section-3">3</a>.  프로토콜 파라미터</span><span class="h3"><a class="selflink" href="#section-3.1" id="section-3.1">3.1</a> HTTP 버전</span>HTTP는 "&lt;주&gt;.&lt;부&gt;" 번호 체계를 사용하여 프로토콜의 버전을 나타냅니다. 프로토콜 버전 관리 정책은 발신자가 해당 통신을 통해 얻은 기능보다는 메시지의 형식과 추가 HTTP 통신을 이해하기 위한 용량을 표시할 수 있도록 하기 위한 것입니다. 통신 동작에 영향을 미치지 않거나 확장 가능한 필드 값에만 추가되는 메시지 구성 요소의 추가에 대해서는 버전 번호가 변경되지 않습니다. 프로토콜 변경으로 인해 일반적인 메시지 구문 분석 알고리즘은 변경되지 않지만 메시지 의미론에 추가되고 발신자의 추가 기능을 의미할 수 있는 기능이 추가되면 &lt;마이너&gt; 번호가 증가합니다. 프로토콜 내에서 메시지 형식이 변경되면 &lt;주&gt; 숫자가 증가합니다. HTTP 메시지의 버전은 메시지 첫 줄의 HTTP-Version 필드에 표시됩니다. 프로토콜 버전이 지정되지 않은 경우 수신자는 메시지가<span class="grey">버너스-리 등 정보 [12페이지</span>]에 있는 것으로 간주해야 합니다.</pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-13"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>단순 HTTP/0.9 형식. HTTP-Version = "HTTP" "/" 1*DIGIT "." 1*DIGIT 메이저와 마이너 숫자는 별도의 정수로 취급해야 하며 각각 한 자리보다 높게 증분될 수 있음에 유의하세요. 따라서 HTTP/2.4는 HTTP/2.13보다 하위 버전이며, 이는 다시 HTTP/12.3보다 하위 버전입니다. 수신자는 선행 0을 무시해야 하며 발신자는 선행 0을 생성해서는 안 됩니다. 이 문서는 HTTP 프로토콜의 0.9 버전과 1.0 버전을 모두 정의합니다. 이 규격에 정의된 대로 전체 요청 또는 전체 응답 메시지를 보내는 애플리케이션은 반드시 "HTTP/1.0" 버전의 HTTP를 포함해야 합니다. HTTP/1.0 서버는: o HTTP/0.9 및 HTTP/1.0 요청의 요청-라인 형식을 인식하고; o HTTP/0.9 또는 HTTP/1.0 형식의 유효한 요청을 이해하고; o 클라이언트에서 사용하는 프로토콜 버전과 동일한 메시지로 적절하게 응답해야 합니다.
 HTTP/1.0 클라이언트는 o HTTP/1.0 응답에 대한 상태 표시줄의 형식을 인식하고, o HTTP/0.9 또는 HTTP/1.0 형식의 유효한 응답을 이해해야 합니다. 프록시 및 게이트웨이 애플리케이션은 애플리케이션의 기본 HTTP 버전과 다른 형식으로 수신된 요청을 전달할 때 주의해야 합니다. 프로토콜 버전은 발신자의 프로토콜 기능을 나타내므로 프록시/게이트웨이는 버전 표시기가 기본 버전보다 큰 메시지를 보내서는 안 되며, 더 높은 버전의 요청이 수신되면 요청 버전을 다운그레이드하거나 오류로 응답해야 합니다. 애플리케이션의 기본 형식보다 낮은 버전의 요청은 전달되기 전에 업그레이드될 수 있으며, 해당 요청에 대한 프록시/게이트웨이의 응답은 위에 나열된 서버 요구 사항을 따라야 합니다.<span class="grey">버너스-리 등 정보 [13페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-14"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><span class="h3"><a class="selflink" href="#section-3.2" id="section-3.2">3.2</a> 유니폼 리소스 식별자</span>URI는 다양한 이름으로 알려져 있습니다: WWW 주소, 범용 문서 식별자, 범용 리소스 식별자<a href="#ref-2" title='"Universal Resource Identifiers in WWW: A Unifying Syntax for the Expression of Names and Addresses of Objects on the Network as used in the World-Wide Web"'>[2</a>], 그리고 마지막으로 URL(Uniform Resource Locator)<a href="#ref-4" title='"Uniform Resource Locators (URL)"'>[4</a>]과 이름(URN)<a href="#ref-16" title='"Functional Requirements for Uniform Resource Names"'>[16</a>]의 조합으로 알려져 있습니다. HTTP에 관한 한, 범용 리소스 식별자는 이름, 위치 또는 기타 특성을 통해 네트워크 리소스를 식별하는 단순한 형식의 문자열입니다.<span class="h4"><a class="selflink" href="#section-3.2.1" id="section-3.2.1">3.2.1</a></span>HTTP의<span class="h4">일반 구문</span>URI는 사용 맥락에 따라 절대 형식으로 표현되거나 알려진 기본 URI<a href="#ref-9" title='"Relative Uniform Resource Locators"'>[9</a>]에 상대적으로 표현될 수 있습니다. 두 형식은 절대 URI가 항상 스키마 이름 뒤에 콜론으로 시작한다는 사실로 구분됩니다. URI = ( 절대URI | 상대URI ) [ "#" 조각 ] 절대URI = 스키마 ":" *( uchar | reserved ) relativeURI = net_path | abs_path | rel_path net_path = "//" net_loc [ abs_path ] abs_path = "/" rel_path rel_path = [ 경로 ] [ ";" params ] [ "?" 쿼리 ] 경로 = fsegment *( "/" 세그먼트 ) fsegment = 1*pchar 세그먼트 = *pchar params = param *( ";" param ) param = *( pchar | "/" ) scheme = 1*( ALPHA | DIGIT | "+" | "-" | "." ) net_loc = *( pchar | ";" | "?" ) query = *( uchar | 예약 ) fragment = *( uchar | 예약 ) pchar = uchar | ":" | "@" | "&amp;" | "=" | "+" uchar = 예약되지 않음 | 이스케이프 예약되지 않음 = 알파 | 숫자 | 안전 | 추가 | 국가 이스케이프 = "%" HEX HEX 예약됨 = ";" | "/" | "?" | ":" | "@" | "&amp;" | "=" | "+" extra = "!" | "*" | "'" | "(" | ")" | "," safe = "$" | "-" | "_" | "." unsafe = CTL | SP | &lt;"&gt; | "#" | "%" | "&lt;" | "&gt;" national = &lt;알파, 숫자,<span class="grey">버너스 리 등을</span> 제외한 모든 옥텟<span class="grey">정보 [페이지 14]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-15"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>예약, 추가, 안전, 안전하지 않음&gt; URL 구문 및 의미론에 대한 자세한 내용은 RFC <a href="./rfc1738">1738</a><a href="#ref-4" title='"Uniform Resource Locators (URL)"'>[4</a>] 및 <a href="./rfc1808">RFC 1808</a><a href="#ref-9" title='"Relative Uniform Resource Locators"'>[9</a>]을 참조하세요. HTTP 서버는 주소의 rel_path 부분을 나타내는 데 허용되는 예약되지 않은 문자 집합에 제한이 없고 HTTP 프록시는 <a href="./rfc1738">RFC</a> 1738에 정의되지 않은 URI에 대한 요청을 받을 수 있으므로 위의 BNF에는 <a href="./rfc1738">RFC 1738에</a> 지정된 유효한 URL에 허용되지 않는 국가 문자가 포함됩니다.<span class="h4"><a class="selflink" href="#section-3.2.2" id="section-3.2.2">3.2.2</a> htt</span>p<span class="h4">URL</span>"http" 체계는 HTTP 프로토콜을 통해 네트워크 리소스를 찾는 데 사용됩니다. 이 섹션에서는 http URL의 체계별 구문과 의미를 정의합니다. http_URL = "http:" "//" host [ ":" port ] [ abs_path ] host = <a href="./rfc1123#section-2.1">&lt;RFC 1123의 섹션 2.1에</a> 정의된 합법적인 인터넷 호스트 도메인 이름 또는 IP 주소(점으로 구분된 10진수 형식) <a href="./rfc1123#section-2.1">&gt;</a> port = *DIGIT 포트가 비어 있거나 지정되지 않으면 포트 80으로 가정합니다. 의미는 식별된 리소스가 해당 호스트의 해당 포트에서 TCP 연결을 수신 대기하는 서버에 있으며 리소스에 대한 Request-URI는 abs_path라는 것입니다. abs_path가 URL에 없는 경우 요청-URI로 사용할 때는 "/"로 지정해야 합니다<a href="#section-5.1.2">(섹션</a><ahref="#section-5.1.2">5.1.2). 참고: HTTP 프로토콜은 전송 계층 프로토콜과 독립적이지만 http URL은 TCP 위치로만 리소스를 식별하므로 TCP가 아닌 리소스는 다른 URI 체계로 식별해야</ahref="#section-5.1.2"> 합니다.<ahref="#section-5.1.2">
 "http" URL의 표준 형식은 호스트의 UPALPHA 문자를 해당 LOALPHA 문자로 변환하고(호스트명은 대소문자를 구분하지 않음), 포트가 80인 경우 [ ":" 포트]를 생략하고 빈 abs_path를 "/"로 대체하면 얻을 수 있습니다.

<span class="h3"><a class="selflink" href="#section-3.3" id="section-3.3">3.3</a> 날짜/시간 형식</span>HTTP/1.0 애플리케이션은 지금까지 날짜/시간 스탬프 표현을 위해 세 가지 형식을 허용해 왔습니다: 1994년 11월 6일 일요일 08:49:37 GMT, <a href="./rfc822">RFC 822</a>, RFC <a href="./rfc1123">1123으로</a> 업데이트된 1994년 11월 6일 일요일 08:49:37 GMT, RFC <a href="./rfc1036">1036으로</a> 폐기된 RFC <a href="./rfc850">850</a>, ANSI C의 asctime() 형식<span class="grey">Berners-Lee 외 정보</span> [<span class="grey">15페이지]</span>.</ahref="#section-5.1.2"></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-16"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>첫 번째 형식은 인터넷 표준으로 선호되며 <a href="./rfc1123">RFC 1123</a><a href="#ref-6" title='"Requirements for Internet hosts - Application and Support"'>[6</a>]( <a href="./rfc822">RFC 822</a><a href="#ref-7" title='"Standard for the Format of ARPA Internet Text Messages"'>[7</a>]의 업데이트)에 정의된 형식의 고정 길이 하위 집합을 나타냅니다. 두 번째 형식은 일반적으로 사용되지만 더 이상 사용되지 않는 <a href="./rfc850">RFC 850</a><a href="#ref-10" title='"Standard for interchange of USENET Messages"'>[10</a>] 날짜 형식을 기반으로 하며 4자리 연도가 없습니다. 날짜 값을 구문 분석하는 HTTP/1.0 클라이언트와 서버는 세 가지 형식을 모두 허용해야 하지만 세 번째(asctime) 형식은 절대 생성해서는 안 됩니다. 참고: 날짜 값의 수신자는 프록시/게이트웨이를 통해 메시지를 검색하거나 SMTP 또는 NNTP로 게시할 때와 같이 비 HTTP 애플리케이션에서 생성되었을 수 있는 날짜 값을 강력하게 허용하는 것이 좋습니다. 모든 날짜/시간 스탬프는 예외 없이 반드시 그리니치 표준시(GMT)로도 알려진 세계 표준시(UT)로 표시해야 합니다. 이는 처음 두 형식에서 시간대의 세 글자 약어로 "GMT"가 포함됨으로써 표시되며, asctime 형식을 읽을 때 이를 가정해야 합니다.
 HTTP-date = <a href="./rfc1123">rfc1123-date</a>| <a href="./rfc850">rfc850-date</a>| asctime-date <a href="./rfc1123">rfc1123-date</a>= wkday "," SP date1 SP 시간 SP "GMT" <a href="./rfc850">rfc850-date</a>= weekday "," SP date2 SP 시간 SP "GMT" asctime-date = wkday SP date3 SP 시간 SP 4DIGIT date1 = 2DIGIT SP 월 SP 4DIGIT ; 일 월 년 (예, 02 Jun 1982) date2 = 2DIGIT "-" 월 "-" 2DIGIT ; 일-월-년(예: 02-Jun-82) date3 = 월 SP ( 2DIGIT | ( SP 1DIGIT )) ; 월 일(예: Jun 2) time = 2DIGIT ":" 2DIGIT ":" 2DIGIT ; 00:00:00 - 23:59:59 wkday = "Mon" | "화" | "수" | "목" | "금" | "토" | "일" 요일 = "월요일" | "화요일" | "수요일" | "목요일" | "금요일" | "토요일" | "일요일" 월 = "1월" | "2월" | "3월" | "Apr" | "5월" | "6월" | "7월" | "8월" | "9월" | "10월" | "11월" | "12월" 참고: 날짜/시간 스탬프 형식에 대한 HTTP 요구 사항은 프로토콜 스트림 내에서의 사용에만 적용됩니다. 클라이언트와 서버는<span class="grey">버너스-리</span> 등 사용자<span class="grey">정보 [16페이지</span>]를 위해 이러한 형식을 사용할 필요가 없습니다.</pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-17"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>발표, 요청 로깅 등<span class="h3"><a class="selflink" href="#section-3.4" id="section-3.4">3.4</a> 문자 집합</span>HTTP는 "문자 집합"이라는 용어에 대해 MIME에 대해 설명한 것과 동일한 정의를 사용합니다: 이 문서에서 "문자 집합"이라는 용어는 하나 이상의 테이블을 사용하여 일련의 옥텟을 일련의 문자로 변환하는 방법을 지칭하기 위해 사용됩니다. 주어진 문자 세트에서 모든 문자를 사용할 수 있는 것은 아니며 문자 세트가 특정 문자를 표현하기 위해 하나 이상의 옥텟 시퀀스를 제공할 수 있으므로 무조건 다른 방향으로 변환할 필요는 없다는 점에 유의하세요. 이 정의는 US-ASCII와 같은 단순한 단일 테이블 매핑부터 ISO 2022의 기술을 사용하는 복잡한 테이블 전환 방법까지 다양한 종류의 문자 인코딩을 허용하기 위한 것입니다. 단, MIME 문자 집합 이름과 관련된 정의에는 옥텟에서 문자로 수행되는 매핑이 완전히 명시되어 있어야 합니다. 특히 정확한 매핑을 결정하기 위해 외부 프로파일링 정보를 사용하는 것은 허용되지 않습니다. 참고: 이러한 "문자 집합"이라는 용어의 사용은 일반적으로 "문자 인코딩"이라고 불립니다. 그러나 HTTP와 MIME은 동일한 레지스트리를 공유하므로 용어 또한 공유하는 것이 중요합니다. HTTP 문자 집합은 대소문자를 구분하지 않는 토큰으로 식별됩니다. 전체 토큰 세트는 IANA 문자 집합 레지스트리<a href="#ref-15" title='"Assigned Numbers"'>[15</a>]에 정의되어 있습니다. 그러나 이 레지스트리는 각 문자 집합에 대해 일관된 단일 토큰을 정의하지 않기 때문에 여기서는 HTTP 엔티티에 가장 많이 사용되는 문자 집합에 대해 선호하는 이름을 정의합니다. 이러한 문자 세트에는 <a href="./rfc1521">RFC 1521</a><a href="#ref-5" title='"MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies"'>[5</a>]에 등록된 문자 세트, 즉 US-ASCII<a href="#ref-17" title="ANSI">[17</a>] 및 ISO-8859<a href="#ref-18" title="ISO 8859-2">[18</a>] 문자 세트와 MIME 문자 세트 매개변수 내에서 사용하도록 특별히 권장되는 기타 이름이 포함됩니다.
   charset = "US-ASCII" | "ISO-8859-1" | "ISO-8859-2" | "ISO-8859-3" | "ISO-8859-4" | "ISO-8859-5" | "ISO-8859-6" | "ISO-8859-7" | "ISO-8859-8" | "ISO-8859-9" | "ISO-2022-JP" | "ISO-2022-JP-2" | "ISO-2022-KR"   | "UNICODE-1-1" | "UNICODE-1-1-UTF-7" | "UNICODE-1-1-UTF-8" | 토큰 HTTP에서는 임의의 토큰을 문자셋 값으로 사용할 수 있지만, IANA 문자셋 레지스트리<a href="#ref-15" title='"Assigned Numbers"'>[15</a>] 내에 사전 정의된 값을 가진 토큰은 반드시<span class="grey">Berners-Lee 등에</span> 정의된 문자셋을 나타나야 합니다 [<span class="grey">17페이지 정보]</span>.</pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-18"></span>
해당 레지스트리의<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>. 애플리케이션은 문자 집합 사용을 IANA 레지스트리에 정의된 것으로 제한해야 합니다. 엔티티 본문의 문자 집합은 해당 본문 내에서 사용되는 문자 코드의 최하위 공통 분모로 레이블을 지정해야 하지만 US-ASCII 또는 ISO-8859-1 레이블보다 선호되지 않습니다.<span class="h3"><a class="selflink" href="#section-3.5" id="section-3.5">3.5</a> 콘텐츠 코</span>딩 콘텐츠 코딩 값은 자원에 적용된 인코딩 변환을 표시하는 데 사용됩니다. 콘텐츠 코딩은 주로 기본 미디어 유형의 신원을 잃지 않고 문서를 압축하거나 암호화할 수 있도록 하는 데 사용됩니다. 일반적으로 리소스는 이 인코딩으로 저장되며 렌더링 또는 이와 유사한 사용 전에만 디코딩됩니다. content-coding = "x-gzip" | "x-compress" | 토큰 참고: 향후 호환성을 위해 HTTP/1.0 애플리케이션은 "gzip" 및 "compress"를 각각 "x-gzip" 및 "x-compress"와 동일한 것으로 간주해야 합니다. 모든 content-coding 값은 대소문자를 구분하지 않습니다. HTTP/1.0은 Content-Encoding<a href="#section-10.3">(섹션 10.3</a>) 헤더 필드에 콘텐츠-코딩 값을 사용합니다. 이 값은 콘텐츠 인코딩을 설명하지만, 더 중요한 것은 인코딩을 제거하는 데 필요한 디코딩 메커니즘을 나타낸다는 것입니다. 하나의 프로그램이 여러 콘텐츠 코딩 형식을 디코딩할 수 있다는 점에 유의하세요. 이 사양에는 다음 두 가지 값이 정의되어 있습니다: x-gzip Jean-loup Gailly가 개발한 파일 압축 프로그램 "gzip"(GNU zip)에서 생성된 인코딩 형식입니다. 이 형식은 일반적으로 32비트 CRC를 사용하는 렘펠-지브 코딩(LZ77)입니다. x-compress 파일 압축 프로그램 "compress"에서 생성하는 인코딩 형식입니다. 이 형식은 적응형 렘펠-지브-웰치 코딩(LZW)입니다. 참고: 인코딩 포맷을 식별하기 위해 프로그램 이름을 사용하는 것은 바람직하지 않으며 향후 인코딩에는 사용하지 않는 것이 좋습니다. 여기서 사용하는 것은 좋은 디자인이 아니라 과거의 관행을 대표하는 것입니다.<span class="grey">Berners-Lee 외 정보 [18페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-19"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><span class="h3"><a class="selflink" href="#section-3.6" id="section-3.6">3.6</a> 미디어 타입</span>HTTP는 개방적이고 확장 가능한 데이터 타입을 제공하기 위해 Content-Type 헤더 필드<a href="#section-10.5">(섹션 10.5</a>)에서 인터넷 미디어 타입<a href="#ref-13" title='"Media Type Registration Procedure."'>[13</a>]을 사용합니다.
 미디어 타입 = 타입 "/" 서브타입 *( ";" 파라미터 ) 타입 = 토큰 서브타입 = 토큰 파라미터는 속성/값 쌍의 형태로 타입/서브타입 뒤에 올 수 있습니다. 파라미터 = 속성 "=" 값 속성 = 토큰 값 = 토큰 | 따옴표- 문자열 타입, 서브타입 및 파라미터 속성 이름은 대소문자를 구분하지 않습니다. 매개변수 값은 매개변수 이름의 의미에 따라 대소문자를 구분할 수도 있고 구분하지 않을 수도 있습니다. 유형과 하위 유형 사이 또는 속성과 해당 값 사이에 LWS를 생성해서는 안 됩니다. 인식할 수 없는 파라미터가 포함된 미디어 유형을 수신하면 사용자 에이전트는 인식할 수 없는 파라미터와 해당 값이 없는 것처럼 미디어 유형을 처리해야 합니다. 일부 구형 HTTP 애플리케이션은 미디어 유형 파라미터를 인식하지 못합니다. HTTP/1.0 애플리케이션은 메시지 내용을 정의하는 데 필요한 경우에만 미디어 유형 매개변수를 사용해야 합니다. 미디어 유형 값은 인터넷 할당 번호 기관(IANA<a href="#ref-15" title='"Assigned Numbers"'>[15</a>])에 등록됩니다. 미디어 유형 등록 절차는 <a href="./rfc1590">RFC 1590</a><a href="#ref-13" title='"Media Type Registration Procedure."'>[13</a>]에 설명되어 있습니다. 등록되지 않은 미디어 타입의 사용은 권장하지 않습니다.<span class="h4"><a class="selflink" href="#section-3.6.1" id="section-3.6.1">3.6.1</a> 표준화 및 텍스트 기본값</span>인터넷 미디어 타입은 표준 양식으로 등록됩니다. 일반적으로 HTTP를 통해 전송되는 엔티티-바디는 전송 전에 적절한 표준 형식으로 표현되어야 합니다. 본문이 콘텐츠 인코딩으로 인코딩된 경우, 기본 데이터는 인코딩되기 전에 표준 형식이어야 합니다. "텍스트" 유형의 미디어 하위 유형은 표준 형식일 때 텍스트 줄 바꿈으로 CRLF를 사용합니다. 그러나 HTTP는 엔티티 본문 내에서 일관되게 사용되는 경우 일반 CR 또는 LF만으로 줄 바꿈을 나타내는 텍스트 미디어의 전송을 허용합니다. HTTP 애플리케이션은 HTTP를 통해 수신된 텍스트 미디어에서 줄 바꿈을 나타내는 것으로 CRLF, 베어 CR 및 베어 LF를 허용해야 합니다.<span class="grey">버너스-리 외 정보 [19페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-20"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>또한 일부 멀티바이트 문자 집합의 경우처럼 텍스트 미디어가 CR과 LF에 각각 13과 10의 옥텟을 사용하지 않는 문자 집합으로 표현되는 경우, HTTP는 해당 문자 집합에 정의된 어떤 옥텟 시퀀스를 사용해도 줄 바꿈에 해당하는 CR과 LF를 표현할 수 있습니다. 줄 바꿈에 대한 이러한 유연성은 엔티티 본문의 텍스트 미디어에만 적용되며, 헤더 필드 및 멀티파트 경계와 같은 HTTP 제어 구조 내에서 CR 또는 LF를 CRLF로 대체해서는 안 됩니다. "charset" 파라미터는 일부 미디어 유형에서 데이터의 문자 집합을 정의하는 데 사용됩니다<a href="#section-3.4">(섹션 3.4</a>). 발신자가 명시적인 문자셋 매개변수를 제공하지 않은 경우, "텍스트" 유형의 미디어 하위 유형은 HTTP를 통해 수신될 때 기본 문자셋 값이 "ISO-8859-1"로 정의됩니다. "ISO-8859-1" 또는 그 하위 집합이 아닌 문자 집합의 데이터는 수신자가 일관되게 해석할 수 있도록 적절한 문자 집합 값으로 레이블을 지정해야 합니다. 참고: 현재 많은 HTTP 서버는 적절한 레이블 없이 "ISO-8859-1" 이외의 문자 집합을 사용하여 데이터를 제공합니다. 이러한 상황은 상호 운용성을 저하시키므로 권장되지 않습니다. 이를 보완하기 위해 일부 HTTP 사용자 에이전트는 문자셋 매개변수가 지정되지 않은 경우 사용자가 미디어 유형 문자 집합의 기본 해석을 변경할 수 있는 구성 옵션을 제공합니다.<span class="h4"><a class="selflink" href="#section-3.6.2" id="section-3.6.2">3.6.2</a> 멀티</span>파트<span class="h4">타입</span>MIME은 단일 메시지의 Entity-Body 내에 여러 엔티티를 캡슐화하는 여러 "멀티파트" 타입을 제공합니다. IANA<a href="#ref-15" title='"Assigned Numbers"'>[15</a>]에 등록된 멀티파트 타입은 HTTP/1.0에서 특별한 의미가 없지만, 사용자 에이전트는 각 본문 부분의 목적을 올바르게 해석하기 위해 각 타입을 이해해야 할 수 있습니다. HTTP 사용자 에이전트는 멀티파트 타입을 수신할 때 MIME 사용자 에이전트와 동일하거나 유사한 동작을 따라야 합니다. HTTP 서버는 모든 HTTP 클라이언트가 멀티파트 타입을 처리할 준비가 되어 있다고 가정해서는 안 됩니다. 모든 멀티파트 타입은 공통 구문을 공유하며 미디어 타입 값의 일부로 경계 매개변수를 포함해야 합니다. 메시지 본문은 그 자체로 프로토콜 요소이므로 본문 부분 사이의 줄 바꿈을 표현할 때는 CRLF만 사용해야 합니다. 여러 부분으로 구성된 본문 부분에는 해당 부분의 의미에 중요한 HTTP 헤더 필드가 포함될 수 있습니다.<span class="h3"><a class="selflink" href="#section-3.7" id="section-3.7">3.7</a> 제품</span>토큰 제품 토큰은 통신하는 애플리케이션이 간단한 제품 토큰과 슬래시 및 버전 지정자(옵션)를 통해 자신을 식별할 수 있도록 하는 데 사용됩니다. 제품 토큰을 사용하는 대부분의 필드에서는 애플리케이션의 중요한 부분을 구성하는 하위 제품도<span class="grey">버너스 리 외 정보 [20페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-21"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월을</span>공백으로 구분하여 나열합니다. 규칙에 따라 제품은 애플리케이션 식별에 중요한 순서대로 나열됩니다. 제품 = 토큰 ["/" 제품 버전] 제품 버전 = 토큰 예: 사용자-에이전트: CERN-LineMode/2.15 libwww/2.17b3 서버: Apache/0.8.4 제품 토큰은 짧고 간결해야 하며, 광고나 기타 필수적이지 않은 정보에 사용하는 것은 명시적으로 금지되어 있습니다. 제품 버전에 토큰 문자가 표시될 수 있지만 이 토큰은 버전 식별자로만 사용해야 합니다(즉, 동일한 제품의 후속 버전은 제품 값의 제품 버전 부분만 달라져야 함).<span class="h2"><a class="selflink" href="#section-4" id="section-4">4</a>.  HTTP</span>메시지<span class="h3"><a class="selflink" href="#section-4.1" id="section-4.1">4.1</a> 메시지 유형</span>HTTP 메시지는 클라이언트에서 서버로의 요청과 서버에서 클라이언트로의 응답으로 구성됩니다. HTTP-message = 단순 요청 ; HTTP/0.9 메시지 | 단순 응답 | 전체 요청 ; HTTP/1.0 메시지 | 전체 응답 전체 요청 및 전체 응답은 엔티티 전송에 <a href="./rfc822">RFC</a><ahref=". rfc822"="">822<a href="#ref-7" title='"Standard for the Format of ARPA Internet Text Messages"'>[7</a>]의 일반 메시지 형식을 사용합니다. 두 메시지 모두 선택적 헤더 필드("헤더"라고도 함)와 엔티티 본문을 포함할 수 있습니다. 엔티티 본문은 헤더와 널 라인으로 구분됩니다(즉, 전체 요청 = 요청-줄 ; <a href="#section-5.1">섹션 5.1</a> *( 일반-헤더 ; <a href="#section-4.3">섹션 4.3</a> | 요청-헤더 ; <a href="#section-5.2">섹션 5.2</a> | 엔티티-헤더 ) ; <a href="#section-7.1">섹션 7.1</a> CRLF [ 엔티티-본문 ] ; 섹션 <a href="#section-7.2">7.2</a>전체 응답 = 상태-줄 ; 섹션 <a href="#section-6.1">6.1</a> *( 일반-헤더 ; <a href="#section-4.3">섹션 4.3</a> | 응답-헤더 ; <a href="#section-6.2">섹션 6.2</a><span class="grey">버너스 리 등 정보 [페이지 21]&lt;</span>/ahref=".&gt;&lt;/pre&gt;&lt;/pre&gt;</ahref=".></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-22"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>| 엔티티-헤더 ) ; <a href="#section-7.1">섹션 7.1</a> CRLF [ 엔티티-본문 ] ; <a href="#section-7.2">섹션 7.2</a>Simple-Request 및 Simple-Response는 헤더 정보를 사용할 수 없으며 단일 요청 방법(GET)으로 제한됩니다. Simple-Request = "GET" SP 요청-URI CRLF Simple-Response = [ 엔티티-본문 ] 서버가 반환되는 엔티티의 미디어 유형을 식별하지 못하도록 하기 위해 Simple-Request 형식의 사용은 권장하지 않습니다.

<span class="h3"><a class="selflink" href="#section-4.2" id="section-4.2">4.2</a> 메시지 헤더</span>일반-헤더<a href="#section-4.3">(섹션 4.3</a>), 요청-헤더<a href="#section-5.2">(섹션 5.2</a>), 응답-헤더<a href="#section-6.2">(섹션 6.2</a>), 엔티티-헤더<a href="#section-7.1">(섹션 7.1</a>) 필드를 포함하는 HTTP 헤더 필드는 <a href="./rfc822#section-3.1">RFC 822</a><a href="#ref-7" title='"Standard for the Format of ARPA Internet Text Messages"'>[7</a>] <a href="./rfc822#section-3.1">의 섹션 3.1에</a> 제시된 것과 동일한 일반 형식을 따릅니다. 각 헤더 필드는 이름 바로 뒤에 콜론(":"), 공백(SP) 문자 하나, 필드 값으로 구성됩니다. 필드 이름은 대소문자를 구분하지 않습니다. 헤더 필드는 각 추가 줄 앞에 하나 이상의 SP 또는 HT를 추가하여 여러 줄에 걸쳐 확장할 수 있지만 권장하지는 않습니다. HTTP-header = 필드 이름 ":" [ 필드 값 ] CRLF 필드 이름 = 토큰 필드 값 = *( 필드 내용 | LWS ) 필드 내용 = &lt;필드 값을 구성하는 OCTET이며 *TEXT 또는 토큰, tspecials 및 따옴표로 묶은 문자열의 조합&gt; 헤더 필드가 수신되는 순서는 중요하지 않습니다. 그러나 일반 헤더 필드를 먼저 보내고 요청 헤더 또는 응답 헤더 필드를 엔티티 헤더 필드보다 먼저 보내는 것이 "좋은 관행"입니다. 동일한 필드 이름을 가진 여러 개의 HTTP 헤더 필드가 메시지 내에 존재할 수 있으며 해당 헤더 필드의 전체 필드 값이 쉼표로 구분된 목록[즉, #(값)]으로 정의된 경우에만 가능합니다. 메시지의 의미를 변경하지 않고, 쉼표로 구분된 각 후속 필드 값을 첫 번째 필드 값에 추가하여 여러 헤더 필드를 하나의 "필드 이름: 필드 값" 쌍으로 결합할 수 있어야 합니다.<span class="grey">버너스 리 외 정보 [22페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-23"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><span class="h3"><a class="selflink" href="#section-4.3" id="section-4.3">4.3</a> 일반 헤더 필드</span>요청 및 응답 메시지 모두에 일반적으로 적용 가능하지만 전송되는 엔티티에는 적용되지 않는 몇 가지 헤더 필드가 있습니다. 이러한 헤더는 전송되는 메시지에만 적용됩니다. 일반-헤더 = 날짜 ; <a href="#section-10.6">섹션 10.6</a> | 프라그마 ; <a href="#section-10.12">섹션 10.12</a>일반 헤더 필드 이름은 프로토콜 버전이 변경된 경우에만 안정적으로 확장할 수 있습니다. 그러나 통신의 모든 당사자가 일반 헤더 필드로 인식하는 경우 새 헤더 필드 또는 실험적인 헤더 필드에 일반 헤더 필드의 의미를 부여할 수 있습니다. 인식되지 않는 헤더 필드는 엔티티-헤더 필드로 취급됩니다<span class="h2"><a class="selflink" href="#section-5" id="section-5">.</a></span><span class="h2">요청</span>클라이언트에서 서버로 보내는 요청 메시지에는 해당 메시지의 첫 줄에 리소스에 적용할 메서드, 리소스의 식별자, 사용 중인 프로토콜 버전이 포함됩니다. 보다 제한된 HTTP/0.9 프로토콜과의 하위 호환성을 위해 HTTP 요청에는 두 가지 유효한 형식이 있습니다: 요청 = 단순 요청 | 전체 요청 단순 요청 = "GET" SP 요청-URI CRLF 전체 요청 = 요청-라인 ; <a href="#section-5.1">섹션 5.1</a> *( 일반-헤더 ; <a href="#section-4.3">섹션 4.3</a> | 요청-헤더 ; <a href="#section-5.2">섹션 5.2</a> | 엔티티-헤더 ) ; <a href="#section-7.1">섹션 7.1</a> CRLF [ 엔티티-바디 ] ; <a href="#section-7.2">섹션 7.2</a>HTTP/1.0 서버가 Simple-Request를 수신하면 HTTP/0.9 Simple-Response로 응답해야 합니다. 전체 응답을 수신할 수 있는 HTTP/1.0 클라이언트는 절대로 단순 요청을 생성해서는 안 됩니다.<span class="h3"><a class="selflink" href="#section-5.1" id="section-5.1">5.1</a> 요청-라인</span>요청-라인은 메소드 토큰으로 시작하여 요청-URI와 프로토콜 버전으로 이어지고 CRLF로 끝납니다. 각 요소는 SP 문자로 구분됩니다. 마지막 CRLF 시퀀스를 제외하고는 CR 또는 LF는 허용되지 않습니다. 요청-라인 = 메서드 SP 요청-URI SP HTTP-버전 CRLF<span class="grey">버너스-리 외 정보 [23페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-24"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>단순 요청과 전체 요청의 요청-라인의 차이점은 HTTP-Version 필드의 존재 여부와 GET 이외의 메서드 사용 가능 여부입니다.<span class="h4"><a class="selflink" href="#section-5.1.1" id="section-5.1.1">5.1.1</a> 메</span>서드 메서드 토큰은 요청-URI로 식별되는 리소스에서 수행될 메서드를 나타냅니다. 메소드는 대소문자를 구분합니다. 메소드 = "GET" ; <a href="#section-8.1">섹션 8.1</a> | "HEAD" ; <a href="#section-8.2">섹션 8.2</a> | "POST" ; <a href="#section-8.3">섹션 8.3</a> | extension-method extension-method = 토큰 특정 리소스에서 허용되는 메소드 목록은 동적으로 변경될 수 있으며 리소스에서 허용되지 않는 경우 응답의 반환 코드를 통해 클라이언트에 알립니다. 서버는 메소드가 인식되지 않거나 구현되지 않은 경우 상태 코드 501(구현되지 않음)을 반환해야 합니다. HTTP/1.0 애플리케이션에서 일반적으로 사용되는 메소드는 <a href="#section-8">섹션 8에</a> 완전히 정의되어 있습니다.<span class="h4"><a class="selflink" href="#section-5.1.2" id="section-5.1.2">5.1.2</a> 요청-URI</span>요청-URI는 통일 리소스 식별자<a href="#section-3.2">(섹션 3.2</a>)이며 요청을 적용할 리소스를 식별합니다. Request-URI = 절대URI | abs_path 요청-URI의 두 가지 옵션은 요청의 성격에 따라 달라집니다. 절대URI 형식은 요청이 프록시에 이루어지는 경우에만 허용됩니다. 프록시는 요청을 전달하고 응답을 반환하도록 요청받습니다. 요청이 GET 또는 HEAD이고 이전 응답이 캐시된 경우 프록시는 만료 헤더 필드에 있는 제한 사항을 통과하면 캐시된 메시지를 사용할 수 있습니다. 프록시는 요청을 다른 프록시로 전달하거나 절대URI로 지정된 서버로 직접 전달할 수 있습니다. 요청 루프를 방지하려면 프록시는 별칭, 로컬 변형, 숫자 IP 주소를 포함한 모든 서버 이름을 인식할 수 있어야 합니다. 요청 줄의 예는 다음과 같습니다: GET <a href="http://www.w3.org/pub/WWW/TheProject.html">http://www.w3.org/pub/WWW/TheProject.html</a> HTTP/1.0<span class="grey">Berners-Lee 등 정보 [24페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-25"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>가장 일반적인 형태의 요청-URI는 원본 서버 또는 게이트웨이에서 리소스를 식별하는 데 사용됩니다. 이 경우 URI의 절대 경로만 전송됩니다( <a href="#section-3.2.1">섹션 3.2.1</a>, abs_path 참조). 예를 들어, 원본 서버에서 위의 리소스를 직접 검색하려는 클라이언트는 호스트 "www.w3.org"의 포트 80에 TCP 연결을 생성하고 GET /pub/WWW/TheProject.html HTTP/1.0 줄과 전체 요청의 나머지 부분을 전송합니다. 절대 경로는 비워둘 수 없으며, 원본 URI에 경로가 없는 경우 "/"(서버 루트)로 지정해야 합니다. Request-URI는 인코딩된 문자열로 전송되며, <a href="./rfc1738">RFC 1738</a><a href="#ref-4" title='"Uniform Resource Locators (URL)"'>[4</a>]에 정의된 "% HEX HEX" 인코딩을 사용하여 일부 문자가 이스케이프될 수 있습니다. 원본 서버는 요청을 올바르게 해석하기 위해 요청-URI를 디코딩해야 합니다.<span class="h3"><a class="selflink" href="#section-5.2" id="section-5.2">5.2</a> 요청 헤</span>더 필드 요청 헤더 필드를 통해 클라이언트는 요청 및 클라이언트 자체에 대한 추가 정보를 서버에 전달할 수 있습니다. 이러한 필드는 프로그래밍 언어 메서드(프로시저) 호출의 매개변수와 동일한 의미를 갖는 요청 수정자 역할을 합니다. 요청 헤더 = 권한 부여, <a href="#section-10.2">섹션 10.2</a> | 보낸 사람, <a href="#section-10.8">섹션 10.8</a> | 수정된 이후, <a href="#section-10.9">섹션 10.9</a> | 참조자, 섹션 10. <a href="#section-10.13">13</a> | 사용자 에이전트, <a href="#section-10.15">섹션 10.15</a>요청 헤더 필드 이름은 프로토콜 버전 변경과 함께만 안정적으로 확장될 수 있습니다. 그러나 통신의 모든 당사자가 요청 헤더 필드라고 인식하는 경우 새 헤더 필드 또는 실험적인 헤더 필드에 요청 헤더 필드의 의미를 부여할 수 있습니다. 인식되지 않는 헤더 필드는 엔티티-헤더 필드로 취급됩니다<span class="h2"><a class="selflink" href="#section-6" id="section-6">.</a></span><span class="h2">응답</span>서버는 요청 메시지를 수신하고 해석한 후 HTTP 응답 메시지 형태로 응답합니다. 응답 = 단순 응답 | 전체 응답 단순 응답 = [ 엔티티-바디 ]<span class="grey">버너스-리 외 정보 [25페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-26"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>풀-응답 = 상태-라인 ; <a href="#section-6.1">섹션 6.1</a> *( 일반-헤더 ; <a href="#section-4.3">섹션 4.3</a> | 응답-헤더 ; <a href="#section-6.2">섹션 6.2</a> | 엔티티-헤더 ) ; <a href="#section-7.1">섹션 7.1</a> CRLF [ 엔티티-바디 ] ; <a href="#section-7.2">섹션 7.2</a>단순 응답은 HTTP/0.9 단순 요청에 응답하거나 서버가 보다 제한된 HTTP/0.9 프로토콜만 지원하는 경우에만 전송해야 합니다. 클라이언트가 HTTP/1.0 Full-Request를 전송하고 Status-Line으로 시작하지 않는 응답을 수신하는 경우, 해당 응답이 Simple-Response라고 가정하고 그에 따라 파싱해야 합니다. 단순 응답은 엔티티 본문으로만 구성되며 서버가 연결을 종료하면 종료됩니다.<span class="h3"><a class="selflink" href="#section-6.1" id="section-6.1">6.1</a> Status-Line</span>전체 응답 메시지의 첫 줄은 프로토콜 버전과 숫자 상태 코드 및 관련 텍스트 구문으로 구성된 Status-Line이며, 각 요소는 SP 문자로 구분됩니다. 마지막 CRLF 시퀀스를 제외하고 CR 또는 LF는 허용되지 않습니다. Status-Line = HTTP-버전 SP 상태 코드 SP 이유-구문 CRLF 상태 줄은 항상 프로토콜 버전과 상태 코드 "HTTP/" 1*DIGIT "." 1*DIGIT SP 3자리 SP(예: "HTTP/1.0 200 ")로 시작하므로 이 표현이 있으면 전체 응답과 단순 응답을 구분하기에 충분합니다. 단순-응답 형식은 엔티티 본문의 시작 부분에 이러한 표현식을 허용하여 전체 요청에 대한 응답으로 제공된 경우 메시지를 잘못 해석할 수 있지만, 대부분의 HTTP/0.9 서버는 "text/html" 유형의 응답으로 제한되므로 이러한 응답은 생성하지 않습니다.<span class="h4"><a class="selflink" href="#section-6.1.1" id="section-6.1.1">6.1.1</a> 상태 코드 및 이유 구문</span>상태 코드 요소는 요청을 이해하고 충족하려는 시도에 대한 3 자리 정수 결과 코드입니다. 이유 문구는 상태 코드에 대한 간단한 텍스트 설명을 제공하기 위한 것입니다. 상태 코드는 오토마타에서 사용하기 위한 것이고 이유 문구는 인간 사용자를 위한 것입니다. 클라이언트는 이유 문구를 검토하거나 표시할 필요가 없습니다.<span class="grey">버너스-리 외 정보 [26페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-27"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>상태 코드의 첫 번째 숫자는 응답의 클래스를 정의합니다. 마지막 두 자리는 어떤 분류 역할도 하지 않습니다. 첫 번째 숫자에는 5가지 값이 있습니다. o 1xx: 정보 - 사용되지 않았지만 향후 사용을 위해 예약됨 o 2xx: 성공 - 작업이 성공적으로 수신, 이해 및 수락됨 o 3xx: 리디렉션 - 요청을 완료하려면 추가 조치를 취해야 함 o 4xx: 클라이언트 오류 - 요청에 잘못된 구문이 포함되어 있거나 요청을 이행할 수 없음 o 5xx: 서버 오류 - 서버가 명백히 유효한 요청을 이행하지 못함 HTTP/1.0에 정의된 숫자 상태 코드의 개별 값과 해당 이유 문구의 예시는 아래에 나와 있습니다. 여기에 나열된 이유 구문은 권장 사항일 뿐이며 프로토콜에 영향을 주지 않고 로컬에 상응하는 것으로 대체할 수 있습니다. 이러한 코드는 <a href="#section-9">섹션 9에</a> 자세히 정의되어 있습니다.
 상태 코드 = "200" ; 확인 | "201" ; 생성됨 | "202" ; 수락됨 | "204" ; 콘텐츠 없음 | "301" ; 영구적으로 이동됨 | "302" ; 일시적으로 이동됨 | "304" ; 수정되지 않음 | "400" ; 잘못된 요청 | "401" ; 권한 없음 | "403" ; 금지됨 | "404" ; 찾을 수 없음 | "500" ; 내부 서버 오류 | "501" ; 구현되지 않음 | "502" ; 잘못된 게이트웨이 | "503" ; 서비스를 사용할 수 없음 | 확장 코드 확장 코드 = 3자리 이유-문구 = *&lt;TEXT, CR, LF 제외&gt; HTTP 상태 코드는 확장 가능하지만 현재 실무에서 일반적으로 인정되는 코드는 위의 코드뿐입니다. HTTP 애플리케이션이 등록된 모든 상태의 의미를 이해할 필요는 없습니다(<span class="grey">버너스-리 등 정보</span> 제공 [<span class="grey">27페이지]</span>).</pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-28"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>코드를 이해하는 것이 바람직하지만, 이러한 이해는 분명히 바람직합니다. 그러나 애플리케이션은 인식할 수 없는 응답을 캐시해서는 안 된다는 점을 제외하고는 첫 번째 숫자로 표시된 상태 코드의 클래스를 이해하고 인식할 수 없는 응답을 해당 클래스의 x00 상태 코드와 동일한 것으로 취급해야 합니다. 예를 들어 클라이언트가 인식할 수 없는 상태 코드 431을 수신하면 요청에 문제가 있는 것으로 간주하고 400 상태 코드를 수신한 것처럼 응답을 처리할 수 있습니다. 이러한 경우 사용자 상담원은 비정상적인 상태를 설명하는 사람이 읽을 수 있는 정보를 포함할 가능성이 높으므로 응답과 함께 반환된 엔티티를 사용자에게 제시해야 합니다.<span class="h3"><a class="selflink" href="#section-6.2" id="section-6.2">6.2</a> 응답 헤</span>더 필드 응답 헤더 필드는 서버가 상태 줄에 넣을 수 없는 응답에 대한 추가 정보를 전달할 수 있게 해줍니다. 이러한 헤더 필드는 서버에 대한 정보와 요청-URI로 식별된 리소스에 대한 추가 액세스 정보를 제공합니다. 응답 헤더 = 위치 ; <a href="#section-10.11">섹션 10.11</a> | 서버 ; <a href="#section-10.14">섹션 10.14</a> | WWW-인증 ; <a href="#section-10.16">섹션 10.16</a>응답 헤더 필드 이름은 프로토콜 버전이 변경된 경우에만 안정적으로 확장할 수 있습니다. 그러나 통신의 모든 당사자가 응답 헤더 필드라고 인식하는 경우 새 헤더 필드 또는 실험적인 헤더 필드에 응답 헤더 필드의 의미를 부여할 수 있습니다. 인식되지 않는 헤더 필드는 엔티티-헤더 필드로<span class="h2"><a class="selflink" href="#section-7" id="section-7">취급됩니다</a>.</span><span class="h2">엔티티</span>전체 요청 및 전체 응답 메시지는 일부 요청 및 응답 내에서 엔티티를 전송할 수 있습니다. 엔티티는 엔티티-헤더 필드와 (보통) 엔티티-바디로 구성됩니다. 이 섹션에서 발신자와 수신자는 엔티티를 보내는 사람과 받는 사람에 따라 클라이언트 또는 서버를 의미합니다.<span class="grey">버너스-리 외 정보 [28페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-29"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><span class="h3"><a class="selflink" href="#section-7.1" id="section-7.1">7.1</a> 엔티티 헤더 필드</span>엔티티-헤더 필드는 엔티티-바디에 대한 선택적 메타정보 또는 본문이 없는 경우 요청으로 식별된 리소스에 대한 정보를 정의합니다. 엔티티-헤더 = 허용 ; <a href="#section-10.1">섹션 10.1</a> | 콘텐츠-인코딩 ; <a href="#section-10.3">섹션 10.3</a> | 콘텐츠-길이 ; <a href="#section-10.4">섹션 10.4</a> | 콘텐츠 유형 ; <a href="#section-10.5">섹션 10.5</a> | 만료 ; <a href="#section-10.7">섹션 10.7</a> | 마지막 수정 ; <a href="#section-10.10">섹션 10.10</a> | 확장 헤더 확장 헤더 = HTTP-헤더 확장 헤더 메커니즘을 사용하면 프로토콜 변경 없이 추가 엔티티 헤더 필드를 정의할 수 있지만 이러한 필드는 수신자가 인식할 수 있다고 가정할 수 없습니다. 인식할 수 없는 헤더 필드는 수신자가 무시하고 프록시를 통해 전달해야 합니다.<span class="h3"><a class="selflink" href="#section-7.2" id="section-7.2">7.2</a> 엔티티 본문</span>HTTP 요청 또는 응답과 함께 전송되는 엔티티 본문(있는 경우)은 엔티티-헤더 필드에 정의된 형식과 인코딩을 사용합니다. 엔티티 본문 = *OCTET 요청 메서드가 요청 메시지를 호출할 때만 엔티티 본문이 요청 메시지에 포함됩니다. 요청에 엔티티 본문이 있다는 것은 요청 메시지 헤더에 Content-Length 헤더 필드가 포함됨으로써 알 수 있습니다. 엔티티 본문이 포함된 HTTP/1.0 요청에는 유효한 Content-Length 헤더 필드가 포함되어야 합니다. 응답 메시지의 경우 엔티티 본문이 메시지에 포함되는지 여부는 요청 메서드와 응답 코드 모두에 따라 달라집니다. HEAD 요청 메서드에 대한 모든 응답은 엔티티 헤더 필드가 있어 본문을 포함한다고 생각할 수 있지만 본문을 포함하지 않아야 합니다. 모든 1xx(정보 제공), 204(콘텐츠 없음), 304(수정되지 않음) 응답에는 본문이 포함되어서는 안 됩니다. 다른 모든 응답에는 엔티티 본문 또는 0으로 정의된 Content-Length 헤더 필드가 포함되어야 합니다.<span class="h4"><a class="selflink" href="#section-7.2.1" id="section-7.2.1">7.2.1</a> 유형</span>엔티티 본문이 메시지에 포함된 경우, 해당 본문의 데이터 유형은 헤더 필드 Content-Type 및 Content- Encoding을 통해 결정됩니다. 이는 2계층의 정렬된 인코딩 모델을 정의합니다:<span class="grey">Berners-Lee 등 정보 [29페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-30"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>엔티티-본문 := Content-Encoding( Content-Type( 데이터 ) ) Content-Type은 기본 데이터의 미디어 타입을 지정합니다. Content-Encoding은 일반적으로 데이터 압축을 위해 유형에 적용된 추가 콘텐츠 코딩을 나타내는 데 사용할 수 있으며, 이는 요청된 리소스의 속성입니다. 콘텐츠 인코딩의 기본값은 없음(즉, ID 함수)입니다. 엔티티 본문을 포함하는 모든 HTTP/1.0 메시지에는 해당 본문의 미디어 타입을 정의하는 Content-Type 헤더 필드가 포함되어야 합니다. 단순 응답 메시지의 경우처럼 Content-Type 헤더에 미디어 유형이 제공되지 않는 경우에만 수신자는 해당 콘텐츠 및/또는 리소스 식별에 사용된 URL의 이름 확장자를 검사하여 미디어 유형을 추측할 수 있습니다. 미디어 유형을 알 수 없는 경우 수신자는 이를 "application/octet-stream" 유형으로 처리해야 합니다.<span class="h4"><a class="selflink" href="#section-7.2.2" id="section-7.2.2">7.2.2</a> 길이</span>엔티티 본문이 메시지에 포함된 경우, 해당 본문의 길이는 두 가지 방법 중 하나로 결정될 수 있습니다. Content-Length 헤더 필드가 있는 경우, 그 바이트 단위의 값이 Entity-Body의 길이를 나타냅니다. 그렇지 않은 경우 본문 길이는 서버의 연결 종료에 의해 결정됩니다. 연결을 종료하면 서버가 응답을 다시 보낼 가능성이 없으므로 요청 본문의 끝을 나타내는 데 사용할 수 없습니다. 따라서 엔티티 본문이 포함된 HTTP/1.0 요청에는 유효한 Content-Length 헤더 필드가 포함되어야 합니다. 요청에 엔티티 본문이 포함되어 있는데 Content-Length가 지정되지 않았고 서버가 다른 필드에서 길이를 인식하지 못하거나 계산할 수 없는 경우 서버는 400(잘못된 요청) 응답을 보내야 합니다. 참고: 일부 구형 서버는 데이터 스트림에 동적으로 삽입된 서버 측 포함을 포함하는 문서를 전송할 때 잘못된 Content-Length를 제공합니다. 이는 향후 버전의 HTTP에서는 허용되지 않는다는 점을 강조해야 합니다. 클라이언트가 규정을 준수하는 서버로부터 응답을 수신하고 있다는 것을 알지 못하는 한, Content-Length 값이<span class="h2"><a class="selflink" href="#section-8" id="section-8">올바른지</a></span>여부에 의존해서는 안 됩니다<span class="h2">.</span><span class="h2">메서드 정의</span>HTTP/1.0의 일반적인 메서드 집합은 다음과 같습니다. 이 집합은 확장될 수 있지만, 추가 메서드가 개별적으로 확장된 클라이언트와 서버에 대해 동일한 의미를 공유한다고 가정할 수는 없습니다.<span class="grey">버너스-리 외 정보 [30페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-31"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><span class="h3"><a class="selflink" href="#section-8.1" id="section-8.1">8.1</a> GET</span>메서드는 요청-URI에 의해 식별되는 모든 정보(엔티티 형태)를 검색하는 것을 의미합니다. 요청-URI가 데이터를 생성하는 프로세스를 참조하는 경우, 해당 텍스트가 프로세스의 출력인 경우를 제외하고는 프로세스의 소스 텍스트가 아닌 생성된 데이터가 응답의 엔티티로 반환됩니다. 요청 메시지에 If-Modified-Since 헤더 필드가 포함된 경우 GET 메서드의 의미는 "조건부 GET"으로 변경됩니다. 조건부 GET 메서드는 <a href="#section-10.9">10.9절에</a> 설명된 대로 If-Modified-Since 헤더에 지정된 날짜 이후에 수정된 경우에만 식별된 리소스를 전송하도록 요청합니다. 조건부 GET 메서드는 여러 번 요청하거나 불필요한 데이터를 전송하지 않고 캐시된 엔티티를 새로 고칠 수 있도록 하여 네트워크 사용량을 줄이기 위한 것입니다.<span class="h3"><a class="selflink" href="#section-8.2" id="section-8.2">8.2</a> HEAD</span>서버가 응답에서 엔티티-바디를 반환하지 않아야 한다는 점을 제외하면 HEAD 메서드는 GET과 동일합니다. HEAD 요청에 대한 응답으로 HTTP 헤더에 포함된 메타정보는 GET 요청에 대한 응답으로 전송된 정보와 동일해야 합니다. 이 메서드는 엔티티-바디 자체를 전송하지 않고 요청-URI로 식별된 리소스에 대한 메타정보를 얻는 데 사용할 수 있습니다. 이 메서드는 하이퍼텍스트 링크의 유효성, 접근성 및 최근 수정 여부를 테스트하는 데 자주 사용됩니다. 조건부 GET과 유사한 "조건부 HEAD" 요청은 없습니다. If-Modified-Since 헤더 필드가 HEAD 요청에 포함되어 있으면 무시해야 합니다.<span class="h3"><a class="selflink" href="#section-8.3" id="section-8.3">8.3</a> POST P</span>OST 메서드는 대상 서버가 요청에 포함된 엔티티를 요청-줄의 Request-URI로 식별된 리소스의 새 하위 항목으로 수락하도록 요청하는 데 사용됩니다. POST는 다음과 같은 기능을 통일된 방법으로 처리할 수 있도록 설계되었습니다: o 기존 리소스에 주석 달기, o 게시판, 뉴스그룹, 메일링 리스트 또는 유사한 글 그룹에 메시지 게시, o 데이터 처리 프로세스에 양식<a href="#ref-3" title='"Hypertext Markup Language - 2.0"'>[3</a>] 제출 결과와 같은 데이터 블록 제공, o 추가 작업을 통해 데이터베이스 확장.<span class="grey">Berners-Lee 외 정보 [31페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-32"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>POST 메서드가 수행하는 실제 기능은 서버에 의해 결정되며 일반적으로 요청-URI에 따라 달라집니다. 게시된 엔티티는 파일이 포함된 디렉터리에 종속되거나 뉴스 기사가 게시된 뉴스 그룹에 종속되거나 레코드가 데이터베이스에 종속되는 것과 같은 방식으로 해당 URI에 종속됩니다. 성공적인 POST는 엔티티를 원본 서버에서 리소스로 만들거나 나중에 참조할 수 있도록 액세스할 수 있도록 만들 필요가 없습니다. 즉, POST 메서드에 의해 수행된 작업으로 인해 URI로 식별할 수 있는 리소스가 생성되지 않을 수 있습니다. 이 경우 응답에 결과를 설명하는 엔티티가 포함되어 있는지 여부에 따라 200(확인) 또는 204(콘텐츠 없음)가 적절한 응답 상태입니다. 원본 서버에서 리소스가 생성된 경우 응답은 201(생성됨)이며 요청 상태를 설명하고 새 리소스를 참조하는 엔티티(가급적 "text/html" 유형)를 포함해야 합니다. 모든 HTTP/1.0 POST 요청에 유효한 Content-Length가 필요합니다. HTTP/1.0 서버는 요청 메시지의 콘텐츠 길이를 확인할 수 없는 경우 400(잘못된 요청) 메시지로 응답해야 합니다. 애플리케이션은 서버가 향후 요청에서 동일한 응답을 반환할지 알 수 없으므로 POST 요청에 대한 응답을 캐시하지 않아야 합니다.<span class="h2"><a class="selflink" href="#section-9" id="section-9">9</a>.  상태 코드 정의</span>각 상태 코드는 아래에 설명되어 있으며, 어떤 메서드를 따를 수 있는지와 응답에 필요한 메타 정보를 포함합니다.<span class="h3"><a class="selflink" href="#section-9.1" id="section-9.1">9.1</a> 정보 1xx</span>이 상태 코드 클래스는 상태 줄과 선택적 헤더로만 구성되며 빈 줄로 종료되는 임시 응답을 나타냅니다. HTTP/1.0은 1xx 상태 코드를 정의하지 않으며 HTTP/1.0 요청에 대한 유효한 응답이 아닙니다. 그러나 이 사양의 범위를 벗어난 실험적인 애플리케이션에는 유용할 수 있습니다.<span class="h3"><a class="selflink" href="#section-9.2" id="section-9.2">9.2</a> 성공 2xx</span>이 상태 코드 클래스는 클라이언트의 요청이 성공적으로 수신, 이해 및 수락되었음을 나타냅니다.<span class="grey">버너스-리 외 정보 [32페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-33"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월 16일</span>200 OK 요청이 성공했습니다. 응답과 함께 반환되는 정보는 요청에 사용된 메서드에 따라 달라집니다. 요청된 리소스에 해당하는 엔티티가 응답으로 전송되는 GET, 응답에는 헤더 정보만 포함되고 엔티티 본문은 포함되지 않는 HEAD, 작업의 결과를 설명하거나 포함하는 엔티티가 포함된 POST 201 생성 요청이 이행되어 새 리소스가 생성되었습니다. 새로 생성된 리소스는 응답의 엔티티에 반환된 URI로 참조할 수 있습니다. 원본 서버는 이 상태 코드를 사용하기 전에 리소스를 생성해야 합니다. 즉시 작업을 수행할 수 없는 경우 서버는 리소스를 사용할 수 있는 시점에 대한 설명을 응답 본문에 포함해야 하며, 그렇지 않으면 202(수락됨)로 응답해야 합니다. 이 규격에 정의된 방법 중 POST만 리소스를 생성할 수 있습니다. 202 수락됨 요청이 처리 수락되었지만 처리가 완료되지 않았습니다. 요청이 실제로 처리될 때 거부될 수 있으므로 요청이 최종적으로 처리될 수도 있고 처리되지 않을 수도 있습니다. 이와 같은 비동기 작업에서 상태 코드를 다시 전송하는 기능은 없습니다. 202 응답은 의도적으로 비커밋입니다. 그 목적은 프로세스가 완료될 때까지 사용자 에이전트의 서버 연결이 유지될 필요 없이 서버가 다른 프로세스(예: 하루에 한 번만 실행되는 배치 지향 프로세스)에 대한 요청을 수락할 수 있도록 하기 위한 것입니다. 이 응답과 함께 반환되는 엔티티에는 요청의 현재 상태 표시와 상태 모니터에 대한 포인터 또는 사용자가 요청이 완료될 것으로 예상할 수 있는 예상 시간이 포함되어야 합니다. 204 콘텐츠 없음 서버가 요청을 완료했지만 다시 보낼 새 정보가 없습니다. 클라이언트가 사용자 에이전트인 경우, 요청을 일으킨 문서 보기를<span class="grey">버너스-리 등 정보 [33페이지</span>]로 변경해서는 안 됩니다.</pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-34"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월에</span>생성되었습니다. 이 응답은 주로 사용자 에이전트의 활성 문서 보기를 변경하지 않고 스크립트 또는 기타 작업을 위한 입력을 허용하기 위한 것입니다. 응답에는 현재 사용자 에이전트의 활성 보기에 있는 문서에 적용되어야 하는 엔티티 헤더 형태의 새로운 메타정보가 포함될 수 있습니다.<span class="h3"><a class="selflink" href="#section-9.3" id="section-9.3">9.3</a> 리디렉션 3xx</span>이 상태 코드 클래스는 요청을 이행하기 위해 사용자 에이전트가 추가 조치를 취해야 함을 나타냅니다. 필요한 작업은 후속 요청에 사용된 메서드가 GET 또는 HEAD인 경우에만 사용자와의 상호 작용 없이 사용자 에이전트가 수행할 수 있습니다. 사용자 에이전트는 요청을 5회 이상 자동으로 리디렉션해서는 안 됩니다. 이러한 리디렉션은 일반적으로 무한 루프를 의미하기 때문입니다. 300 다중 선택 이 응답 코드는 HTTP/1.0 애플리케이션에서 직접 사용되지는 않지만 3xx 클래스 응답을 해석하는 데 기본값으로 사용됩니다. 요청된 리소스는 하나 이상의 위치에서 사용할 수 있습니다. HEAD 요청이 아닌 한, 응답에는 사용자 또는 사용자 에이전트가 가장 적합한 리소스를 선택할 수 있는 리소스 특성 및 위치 목록이 포함된 엔티티가 포함되어야 합니다. 서버에 선호하는 선택 항목이 있는 경우 위치 필드에 URL을 포함해야 하며, 사용자 에이전트는 이 필드 값을 사용하여 자동 리디렉션할 수 있습니다. 301 영구적으로 이동 요청된 리소스에 새 영구 URL이 할당되었으며 향후 이 리소스에 대한 모든 참조는 해당 URL을 사용하여 수행해야 합니다. 링크 편집 기능이 있는 클라이언트는 가능한 경우 서버가 반환한 새 참조로 요청-URI에 대한 참조를 자동으로 리링크해야 합니다. 새 URL은 응답의 위치 필드에 제공되어야 합니다. HEAD 요청이 아니라면 응답의 엔티티 본문에는 새 URL로 연결되는 하이퍼링크가 포함된 짧은 메모가 포함되어야 합니다. POST 방식을 사용한 요청에 대한 응답으로 301 상태 코드가 수신되면 요청이 발행된 조건이 변경될 수 있으므로 사용자가 확인할 수 없는 한 사용자 에이전트는 요청을 자동으로 리디렉션해서는 안 됩니다.<span class="grey">버너스-리 외 정보 [34페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-35"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>참고: 301 상태 코드를 받은 후 POST 요청을 자동으로 리디렉션할 때 일부 기존 사용자 에이전트는 이를 GET 요청으로 잘못 변경합니다. 302 일시적으로 이동 요청된 리소스가 다른 URL에 일시적으로 존재합니다. 리디렉션은 때때로 변경될 수 있으므로 클라이언트는 향후 요청에 계속해서 Request-URI를 사용해야 합니다. URL은 응답의 위치 필드에 제공해야 합니다. HEAD 요청이 아니라면 응답의 엔티티 본문에는 새 URI로 연결되는 하이퍼링크가 포함된 짧은 메모가 포함되어야 합니다. POST 방식을 사용한 요청에 대한 응답으로 302 상태 코드가 수신되면 요청이 발행된 조건이 변경될 수 있으므로 사용자가 확인할 수 없는 한 사용자 에이전트는 요청을 자동으로 리디렉션하지 않아야 합니다.
 참고: 302 상태 코드를 수신한 후 POST 요청을 자동으로 리디렉션하는 경우 일부 기존 사용자 에이전트는 이를 GET 요청으로 잘못 변경합니다. 304 수정되지 않음 클라이언트가 조건부 GET 요청을 수행했고 액세스가 허용되었지만 If-Modified-Since 필드에 지정된 날짜 및 시간 이후 문서가 수정되지 않은 경우 서버는 이 상태 코드를 사용하여 응답해야 하며 클라이언트에게 Entity-Body를 보내지 않아야 합니다. 응답에 포함된 헤더 필드에는 캐시 관리자와 관련이 있거나 엔티티의 마지막 수정 날짜와는 독립적으로 변경되었을 수 있는 정보만 포함되어야 합니다. 관련 헤더 필드의 예는 다음과 같습니다: 날짜, 서버 및 만료. 캐시는 304 응답에 제공된 새 필드 값을 반영하도록 캐시된 엔티티를 업데이트해야 합니다.<span class="h3"><a class="selflink" href="#section-9.4" id="section-9.4">9.4</a> 클라이언트 오류 4xx</span>상태 코드의 4xx 클래스는 클라이언트에 오류가 발생한 것으로 보이는 경우를 위한 것입니다. 클라이언트가 4xx 코드를 수신했을 때 요청을 완료하지 않은 경우 즉시 서버로의 데이터 전송을 중단해야 합니다. HEAD 요청에 응답하는 경우를 제외하고 서버는 오류 상황에 대한 설명과 일시적인 상태인지 영구적인 상태인지에 대한 설명이 포함된 엔티티를 포함해야 합니다. 이러한 상태 코드는 모든 요청 방법에 적용 가능합니다.<span class="grey">버너스 리 외 정보 [35페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-36"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>참고: 클라이언트가 데이터를 전송하는 경우, TCP의 서버 구현은 입력 연결을 닫기 전에 클라이언트가 응답이 포함된 패킷의 수신을 승인하도록 주의해야 합니다. 닫은 후에도 클라이언트가 서버에 데이터를 계속 전송하면 서버의 컨트롤러가 클라이언트에 리셋 패킷을 전송하여 클라이언트의 승인되지 않은 입력 버퍼를 HTTP 애플리케이션에서 읽고 해석하기 전에 지울 수 있습니다. 400 잘못된 요청 잘못된 구문으로 인해 서버가 요청을 이해할 수 없습니다. 클라이언트는 수정 없이 요청을 반복해서는 안 됩니다. 401 권한이 없음 요청에 사용자 인증이 필요합니다. 응답에는 요청된 리소스에 적용되는 챌린지가 포함된 WWW-Authenticate 헤더 필드<a href="#section-10.16">(섹션 10.16</a>)가 포함되어야 합니다. 클라이언트는 적절한 권한 부여 헤더 필드를 사용하여 요청을 반복할 수 있습니다<a href="#section-10.2">(섹션 10.2)</a>. 요청에 이미 권한 부여 자격 증명이 포함된 경우 401 응답은 해당 자격 증명에 대한 권한 부여가 거부되었음을 나타냅니다. 401 응답에 이전 응답과 동일한 챌린지가 포함되어 있고 사용자 에이전트가 이미 한 번 이상 인증을 시도한 경우, 해당 엔티티에 관련 진단 정보가 포함될 수 있으므로 사용자에게 응답에 제공된 엔티티를 제시해야 합니다. HTTP 액세스 인증은 <a href="#section-11">섹션 11에</a> 설명되어 있습니다. 403 금지됨 서버가 요청을 이해했지만 이행을 거부하고 있습니다. 권한 부여는 도움이 되지 않으며 요청을 반복해서는 안 됩니다. 요청 메서드가 HEAD가 아니고 서버가 요청을 이행하지 않은 이유를 공개하려는 경우 엔티티 본문에 거부 이유를 설명해야 합니다. 이 상태 코드는 서버가 요청이 거부된 이유를 정확히 밝히기를 원하지 않거나 다른 응답이 적용되지 않을 때 일반적으로 사용됩니다. 404 찾을 수 없음 서버가 요청 URL과 일치하는 항목을 찾지 못했습니다. 이 상태가 일시적인지 영구적인지 여부는 표시되지 않습니다. 서버가 이 정보를 클라이언트에 제공하지 않으려는 경우 상태 코드 403(금지됨)을 대신 사용할 수 있습니다.<span class="grey">버너스-리 등 정보 [36페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-37"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><span class="h3"><a class="selflink" href="#section-9.5" id="section-9.5">9.5</a> 서버 오류 5xx</span>숫자 "5"로 시작하는 응답 상태 코드는 서버가 오류를 인지했거나 요청을 수행할 수 없는 경우를 나타냅니다. 클라이언트가 5xx 코드를 수신했을 때 요청을 완료하지 못했다면 즉시 서버로의 데이터 전송을 중단해야 합니다. HEAD 요청에 응답하는 경우를 제외하고 서버는 오류 상황에 대한 설명과 일시적인 상태인지 영구적인 상태인지에 대한 설명이 포함된 엔티티를 포함해야 합니다. 이 응답 코드는 모든 요청 방법에 적용 가능하며 필수 헤더 필드는 없습니다. 500 내부 서버 오류 서버에서 예기치 않은 조건이 발생하여 요청을 이행할 수 없습니다. 501 구현되지 않음 서버가 요청을 이행하는 데 필요한 기능을 지원하지 않습니다. 서버가 요청 방법을 인식하지 못하고 리소스에 대해 지원할 수 없는 경우 적절한 응답입니다. 502 잘못된 게이트웨이 서버가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 처리하기 위해 액세스한 업스트림 서버로부터 잘못된 응답을 받았습니다. 503 서비스를 사용할 수 없음 서버의 일시적인 과부하 또는 유지 관리로 인해 현재 서버가 요청을 처리할 수 없습니다. 이는 일시적인 상태이며 잠시 후 완화될 것이라는 의미입니다. 참고: 503 상태 코드가 있다고 해서 서버에 과부하가 걸렸을 때 반드시 이 코드를 사용해야 한다는 의미는 아닙니다. 일부 서버는 단순히 연결을 거부할 수도 있습니다<span class="h2">.</span><span class="h2">헤더 필드 정의</span>이 섹션에서는 일반적으로 사용되는 모든 HTTP/1.0 헤더 필드의 구문과 의미를 정의합니다. 일반 및 엔티티 헤더 필드의 경우 발신자와 수신자 모두 메시지를 보내는 사람과 받는 사람에 따라 클라이언트 또는 서버를 참조합니다.<span class="grey">버너스-리 등 정보 [37페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-38"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><span class="h3"><a class="selflink" href="#section-10.1" id="section-10.1">10.1</a> 허용</span>허용 엔티티 헤더 필드에는 요청-URI로 식별된 리소스에서 지원하는 메소드 집합이 나열됩니다. 이 필드의 목적은 리소스와 관련된 유효한 메소드를 수신자에게 알리는 것입니다. 허용 헤더 필드는 POST 메서드를 사용하는 요청에서는 허용되지 않으므로 POST 엔티티의 일부로 수신되는 경우 무시해야 합니다. 허용 = "허용" ":" 1#method 사용 예: 허용: GET, HEAD 이 필드는 클라이언트가 다른 방법을 시도하는 것을 막을 수 없습니다. 그러나 허용 헤더 필드 값의 표시를 따라야 합니다. 허용되는 메소드의 실제 집합은 각 요청 시점에 원본 서버가 정의합니다. 사용자 에이전트가 원본 서버와 통신하는 다른 수단이 있을 수 있으므로 프록시는 지정된 모든 메소드를 이해하지 못하더라도 허용 헤더 필드를 수정해서는 안 됩니다. 허용 헤더 필드는 서버가 구현하는 메소드를 나타내지 않습니다.<span class="h3"><a class="selflink" href="#section-10.2" id="section-10.2">10.2</a></span>인증 서버에 자신을 인증하려는 사용자 에이전트는 일반적으로 401 응답을 받은 후(반드시 그렇지는 않음) 요청에 Authorization 요청 헤더 필드를 포함함으로써 인증할 수 있습니다. Authorization 필드 값은 요청되는 리소스의 영역에 대한 사용자 에이전트의 인증 정보를 포함하는 자격 증명으로 구성됩니다. Authorization = "Authorization" ":" 자격 증명 HTTP 액세스 인증은 <a href="#section-11">섹션 11에</a> 설명되어 있습니다. 요청이 인증되고 영역이 지정되면 이 영역 내의 다른 모든 요청에 대해 동일한 자격 증명이 유효해야 합니다. Authorization 필드가 포함된 요청에 대한 응답은 캐시할 수 없습니다.<span class="grey">버너스 리 외 정보 [38페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-39"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><span class="h3"><a class="selflink" href="#section-10.3" id="section-10.3">10.3</a> Content-Encoding</span>Content-Encoding 엔티티-헤더 필드는 미디어 타입의 수정자로 사용됩니다. 이 값이 있으면 리소스에 어떤 추가 콘텐츠 코딩이 적용되었는지, 따라서 Content-Type 헤더 필드에서 참조하는 미디어 유형을 얻기 위해 어떤 디코딩 메커니즘을 적용해야 하는지를 나타냅니다. Content-Encoding은 주로 기본 미디어 유형의 신원을 잃지 않고 문서를 압축하는 데 사용됩니다. Content-Encoding = "Content-Encoding" ":" 콘텐츠-코딩 콘텐츠 코딩은 <a href="#section-3.5">섹션 3.5에</a> 정의되어 있습니다. 사용 예는 Content-Encoding: x-gzip입니다. Content-Encoding은 Request-URI로 식별되는 리소스의 특성입니다. 일반적으로 리소스는 이 인코딩으로 저장되며 렌더링 또는 이와 유사한 사용 전에만 디코딩됩니다.<span class="h3"><a class="selflink" href="#section-10.4" id="section-10.4">10.4</a> Content</span>-Length 엔티티 헤더 필드는 수신자에게 전송된 Entity-Body의 크기를 십진수 옥텟으로 나타내거나 HEAD 방법의 경우 요청이 GET이었을 때 전송되었을 Entity-Body의 크기를 나타냅니다.
 Content-Length = "Content-Length" ":" 1*DIGIT 예: Content-Length: 3495 애플리케이션은 엔티티의 미디어 유형에 관계없이 이 필드를 사용하여 전송할 엔티티-Body의 크기를 표시해야 합니다. 엔티티 본문이 포함된 모든 HTTP/1.0 요청 메시지에는 유효한 Content-Length 필드 값이 필요합니다. 0보다 크거나 같은 모든 Content-Length가 유효한 값입니다. <a href="#section-7.2.2">7.2.2 섹션에서는</a> Content-Length가 지정되지 않은 경우 응답 엔티티 본문의 길이를 결정하는 방법을 설명합니다. 참고: 이 필드의 의미는 "message/external-body" 콘텐츠 유형 내에서 사용되는 선택적 필드인 MIME의 해당 정의와 크게 다릅니다. HTTP에서는 전송되기 전에 엔티티의 길이를 확인할 수 있을 때마다 사용해야 합니다.<span class="grey">버너스-리 외 정보 [39페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-40"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><span class="h3"><a class="selflink" href="#section-10.5" id="section-10.5">10.5</a> Content</span>-Type 엔티티-헤더 필드는 수신자에게 전송된 Entity-Body의 미디어 타입을 나타내거나 HEAD 메서드의 경우 요청이 GET이었다면 전송되었을 미디어 타입을 나타냅니다. Content-Type = "Content-Type" ":" media-type 미디어 타입은 <a href="#section-3.6">섹션 3.6에</a> 정의되어 있습니다. 이 필드의 예는 Content-Type: text/html 엔티티의 미디어 유형을 식별하는 방법에 대한 자세한 설명은 <a href="#section-7.2.1">섹션 7.2.1에</a> 나와 있습니다.<span class="h3"><a class="selflink" href="#section-10.6" id="section-10.6">10.6</a> 날짜</span>날짜 일반 헤더 필드는 메시지가 시작된 날짜와 시간을 나타내며 <a href="./rfc822">RFC 822의</a> orig-date와 동일한 의미를 갖습니다. 필드 값은 <a href="#section-3.3">섹션</a><ahref="#section-3.3">3.3에</ahref="#section-3.3"> 설명된 대로 HTTP-date입니다<ahref="#section-3.3">. Date = "Date" ":" HTTP-date 예시: Date: Tue, 15 Nov 1994 08:12:31 GMT 사용자 에이전트(요청의 경우) 또는 원본 서버(응답의 경우)와 직접 연결을 통해 메시지를 수신하는 경우 날짜는 수신 측의 현재 날짜로 간주할 수 있습니다. 그러나 원본 서버가 생각하는 날짜는 캐시된 응답을 평가하는 데 중요하므로 원본 서버는 항상 날짜 헤더를 포함해야 합니다. 클라이언트는 POST 요청의 경우처럼 엔티티 본문이 포함된 메시지에만 날짜 헤더 필드를 보내야 하며, 이 경우에도 선택 사항입니다. 날짜 헤더 필드가 없는 수신 메시지가 해당 수신자에 의해 캐시되거나 날짜가 필요한 프로토콜을 통해 게이트웨이를 통과할 경우 수신자가 날짜를 할당해야 합니다. 이론적으로 날짜는 엔티티가 생성되기 직전의 순간을 나타내야 합니다. 실제로 날짜는 의미 값에 영향을 주지 않고 메시지 생성 중 언제든지 생성될 수 있습니다. 참고: 이 문서의 이전 버전에서는 이 필드에 동봉된 Entity-Body의 생성 날짜가 포함되어야 한다고 잘못 지정되어 있었습니다. 이는 실제(그리고 적절한)<span class="grey">Berners-Lee 등 정보</span> [<span class="grey">40페이지</span>]를 반영하도록 변경되었습니다.</ahref="#section-3.3"></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-41"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>사용.<span class="h3"><a class="selflink" href="#section-10.7" id="section-10.7">10.7</a> 만료</span>만료 엔티티 헤더 필드는 엔티티가 오래된 것으로 간주되어야 하는 날짜/시간을 제공합니다. 이를 통해 정보 제공자는 리소스의 변동성 또는 정보가 더 이상 유효하지 않을 수 있는 날짜를 제시할 수 있습니다. 애플리케이션은 지정된 날짜 이후에 이 엔티티를 캐시해서는 안 됩니다. 만료 필드가 있다고 해서 해당 날짜 이전이나 이후에 원본 리소스가 변경되거나 존재하지 않게 된다는 의미는 아닙니다. 그러나 리소스가 특정 날짜까지 변경될 것을 알고 있거나 의심하는 정보 제공업체는 해당 날짜가 포함된 Expires 헤더를 포함해야 합니다. 형식은 <a href="#section-3.3">섹션 3.3의</a> HTTP-date에 정의된 절대 날짜와 시간입니다. Expires = "Expires" ":" HTTP-date 사용 예는 Expires입니다: Thu, 01 Dec 1994 16:00:00 GMT 주어진 날짜가 Date 헤더의 값과 같거나 더 빠르면 수신자는 동봉된 엔티티를 캐시하지 않아야 합니다. 많은 데이터 생성 프로세스의 경우처럼 리소스가 본질적으로 동적인 경우에는 해당 리소스의 엔티티에 해당 동성을 반영하는 적절한 만료 값을 지정해야 합니다. 만료 필드는 사용자 에이전트가 표시를 새로 고치거나 리소스를 다시 로드하는 데 사용할 수 없으며, 그 의미는 캐시 메커니즘에만 적용되며 해당 메커니즘은 리소스에 대한 새 요청이 시작될 때만 만료 상태를 확인하면 됩니다. 사용자 에이전트는 종종 세션에서 이전에 검색한 엔티티를 다시 표시하는 데 사용할 수 있는 "뒤로" 버튼 및 기록 목록 같은 기록 메커니즘을 가지고 있는 경우가 많습니다. 기본적으로 만료 필드는 기록 메커니즘에 적용되지 않습니다. 엔티티가 아직 저장소에 있는 경우 사용자가 만료된 기록 문서를 새로 고치도록 에이전트를 특별히 구성하지 않는 한 엔티티가 만료된 경우에도 기록 메커니즘은 이를 표시해야 합니다. 참고: 애플리케이션은 만료 헤더의 잘못된 또는 잘못된 정보 구현에 관대한 것이 좋습니다. 0 값이나 잘못된 날짜 형식은 "즉시 만료됨"과 동등한 것으로 간주해야 합니다. 이러한 값은 HTTP/1.0에서 합법적이지 않지만 항상 견고한 구현이 바람직합니다.<span class="grey">버너스-리 외 정보 [41페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-42"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><span class="h3"><a class="selflink" href="#section-10.8" id="section-10.8">10.8</a></span>보낸 사람 요청 헤더 필드에는 요청하는 사용자 에이전트를 제어하는 사람의 인터넷 이메일 주소가 포함되어야 합니다. 이 주소는 <a href="./rfc822">RFC 822</a><a href="#ref-7" title='"Standard for the Format of ARPA Internet Text Messages"'>[7</a>](RFC <a href="./rfc1123">1123</a><a href="#ref-6" title='"Requirements for Internet hosts - Application and Support"'>[6</a>]에 의해 업데이트됨)의 사서함에 정의된 대로 기계가 사용할 수 있어야 합니다: From = "From" ":" 사서함 예: webmaster@w3.org 이 헤더 필드는 로깅 목적과 유효하지 않거나 원치 않는 요청의 출처를 식별하는 수단으로 사용될 수 있습니다. 안전하지 않은 형태의 액세스 보호 수단으로 사용해서는 안 됩니다. 이 필드의 해석은 요청이 수행된 방법에 대한 책임을 수락하는 사람을 대신하여 요청이 수행되고 있다는 것입니다. 특히 로봇 에이전트는 수신 측에서 문제가 발생할 경우 로봇을 실행하는 책임자에게 연락할 수 있도록 이 헤더를 포함해야 합니다. 이 필드의 인터넷 이메일 주소는 요청을 보낸 인터넷 호스트와 별개일 수 있습니다. 예를 들어 요청이 프록시를 통해 전달되는 경우 원래 발급자의 주소를 사용해야 합니다. 참고: 사용자의 개인정보 보호 또는 해당 사이트의 보안 정책과 충돌할 수 있으므로 사용자의 승인 없이 보낸 사람 헤더 필드를 전송해서는 안 됩니다. 사용자가 요청 전에 언제든지 이 필드의 값을 비활성화, 활성화 및 수정할 수 있도록 하는 것이 좋습니다.<span class="h3"><a class="selflink" href="#section-10.9" id="section-10.9">10.9</a> If-Modified-Since</span>요청 헤더 필드를 GET 메서드와 함께 사용하여 조건부로 만드는 경우: 이 필드에 지정된 시간 이후 요청된 리소스가 수정되지 않으면 서버에서 리소스 사본이 반환되지 않고 대신 Entity-Body가 없는 304(수정되지 않음) 응답이 반환됩니다.
 If-Modified-Since = "If-Modified-Since" ":" HTTP-date 필드 예: If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT<span class="grey">Berners-Lee, 외 정보 [42페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-43"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>조건부 GET 메서드는 식별된 리소스가 If-Modified-Since 헤더에 지정된 날짜 이후에 수정된 경우에만 전송할 것을 요청합니다. 이를 결정하는 알고리즘에는 다음과 같은 경우가 포함됩니다. a) 요청이 정상적으로 200(확인) 상태가 아닌 다른 상태를 초래하거나 전달된 If-Modified-Since 날짜가 유효하지 않은 경우, 응답은 일반 GET과 완전히 동일합니다. 서버의 현재 시간보다 늦은 날짜는 유효하지 않습니다. b) If-Modified-Since 날짜 이후 리소스가 수정된 경우 응답은 일반 GET과 정확히 동일합니다. c) 유효한 If-Modified-Since 날짜 이후 리소스가 수정되지 않은 경우 서버는 304(수정되지 않음) 응답을 반환해야 합니다.
 이 기능의 목적은 최소한의 트랜잭션 오버헤드로 캐시된 정보를 효율적으로 업데이트하는 것입니다.<span class="h3"><a class="selflink" href="#section-10.10" id="section-10.10">10.10</a> Last-Modified</span>Last-Modified 엔티티 헤더 필드는 발신자가 리소스가 마지막으로 수정되었다고 생각하는 날짜와 시간을 나타냅니다. 이 필드의 정확한 의미는 수신자가 이 필드를 어떻게 해석해야 하는지에 따라 정의됩니다. 수신자가 Last-Modified 필드에 지정된 날짜보다 오래된 리소스 사본을 가지고 있다면 해당 사본은 오래된 것으로 간주해야 합니다. Last-Modified = "Last-Modified" ":" HTTP-date 사용 예는 Last-Modified입니다: Tue, 15 Nov 1994 12:45:26 GMT 이 헤더 필드의 정확한 의미는 발신자의 구현과 원본 리소스의 성격에 따라 다릅니다. 파일의 경우 파일 시스템의 마지막 수정 시간일 수 있습니다. 동적으로 포함된 부분이 있는 엔티티의 경우 해당 구성 요소의 마지막 수정 시간 중 가장 최근의 시간일 수 있습니다. 데이터베이스 게이트웨이의 경우 레코드의 마지막 업데이트 타임스탬프일 수 있습니다. 가상 객체의 경우, 내부 상태가 마지막으로 변경된 시간일 수 있습니다. 원본 서버는 서버의 메시지 시작 시간보다 늦은 마지막 수정 날짜를 전송해서는 안 됩니다. 이러한 경우 리소스의 마지막 수정 날짜는<span class="grey">버너스-리 등 정보 [43페이지</span>]에서 어느 시점을 가리킬 수 있습니다.</pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-44"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>이후에는 서버가 해당 날짜를 메시지 시작 날짜로 대체해야 합니다.<span class="h3"><a class="selflink" href="#section-10.11" id="section-10.11">10.11</a> 위치</span>위치 응답 헤더 필드는 요청-URI로 식별한 리소스의 정확한 위치를 정의합니다. 3xx 응답의 경우 위치는 리소스로의 자동 리디렉션을 위해 서버가 선호하는 URL을 표시해야 합니다. 절대 URL은 하나만 허용됩니다. 위치 = "위치" ":" 절대URI 예: 위치: <a href="http://www.w3.org/hypertext/WWW/NewLocation.html">http://www.w3.org/hypertext/WWW/NewLocation.html</a><span class="h3"><a class="selflink" href="#section-10.12" id="section-10.12">10.12</a> Pr</span>agma 일반 헤더 필드는 요청/응답 체인의 모든 수신자에게 적용될 수 있는 구현별 지시어를 포함시키는 데 사용됩니다. 모든 pragma 지시어는 프로토콜의 관점에서 선택적 동작을 지정하지만, 일부 시스템에서는 해당 동작이 지시어와 일치하도록 요구할 수 있습니다. Pragma = "Pragma" ":" 1#pragma-directive pragma-directive = "no-cache" | extension-pragma extension-pragma = 토큰 [ "=" 단어 ] 요청 메시지에 "no-cache" 지시어가 있는 경우 애플리케이션은 요청된 내용의 캐시된 사본이 있더라도 원본 서버로 요청을 전달해야 합니다. 이를 통해 클라이언트는 자신의 요청에 대해 권한 있는 응답을 받도록 주장할 수 있습니다. 또한 클라이언트는 손상되었거나 오래된 것으로 알려진 캐시된 사본을 새로 고칠 수 있습니다. 프래그마 지시어는 요청/응답 체인의 모든 수신자에게 적용될 수 있으므로 해당 애플리케이션에 대한 중요도와 관계없이 프록시 또는 게이트웨이 애플리케이션을 통해 전달되어야 합니다. 특정 수신자에 대한 프라그마를 지정할 수는 없지만, 수신자와 관련이 없는 프라그마 지시어는 해당 수신자가 무시해야 합니다.<span class="h3"><a class="selflink" href="#section-10.13" id="section-10.13">10.13</a> 참조자</span>참조자 요청 헤더 필드는 클라이언트가 서버의 이익을 위해 요청-URI를 가져온 리소스의 주소(URI)를 지정할 수 있도록 해줍니다. 이를 통해 서버는<span class="grey">버너스-리 등 정보 [44페이지]</span> 목록을 생성할 수 있습니다.</pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-45"></span>
관심 리소스에 대한 백링크, 로깅, 최적화된 캐싱 등을 위한<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>. 또한 유지보수를 위해 더 이상 사용되지 않거나 잘못 입력된 링크를 추적할 수 있습니다. 사용자 키보드 입력과 같이 자체 URI가 없는 소스에서 Request-URI를 가져온 경우 Referer 필드를 전송해서는 안 됩니다. Referer = "Referer" ":" ( 절대URI | 상대URI ) 예: Referer: <a href="http://www.w3.org/hypertext/DataSources/Overview.html">http://www.w3.org/hypertext/DataSources/Overview.html</a>부분 URI가 제공되면 Request-URI를 기준으로 해석해야 합니다. URI에는 조각이 포함되어서는 안 됩니다. 참고: 링크의 출처가 개인 정보이거나 다른 개인 정보 출처를 드러낼 수 있으므로 사용자가 Referer 필드를 보낼지 여부를 선택할 수 있도록 하는 것이 좋습니다. 예를 들어, 브라우저 클라이언트에 공개/익명으로 검색할 수 있는 토글 스위치가 있어 각각 리퍼러 및 출처 정보 전송을 활성화/비활성화할 수 있습니다.<span class="h3"><a class="selflink" href="#section-10.14" id="section-10.14">10.14</a> 서버</span>서버 응답 헤더 필드에는 원본 서버에서 요청을 처리하는 데 사용하는 소프트웨어에 대한 정보가 포함되어 있습니다. 이 필드에는 여러 개의 제품 토큰<a href="#section-3.7">(섹션 3.7)</a>과 서버 및 중요한 하위 제품을 식별하는 주석이 포함될 수 있습니다. 관례에 따라 제품 토큰은 애플리케이션 식별에 중요한 순서대로 나열됩니다. 서버 = "서버" ":" 1*( 제품 | 코멘트 ) 예: 서버: CERN/3.0 libwww/2.17 응답이 프록시를 통해 전달되는 경우 프록시 애플리케이션은 해당 데이터를 제품 목록에 추가하지 않아야 합니다. 참고: 서버의 특정 소프트웨어 버전을 공개하면 서버 컴퓨터가 보안 취약점이 있는 것으로 알려진 소프트웨어에 대한 공격에 더 취약해질 수 있습니다. 서버 구현자는 이 필드를 구성 가능한 옵션으로 설정하는 것이 좋습니다.<span class="grey">버너스-리 외 정보 [45페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-46"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>참고: 일부 기존 서버는 서버 필드 내의 제품 토큰 구문으로 제한하지 못합니다.<span class="h3"><a class="selflink" href="#section-10.15" id="section-10.15">10.15</a> 사용자 에이전</span>트 사용자 에이전트 요청 헤더 필드에는 요청을 시작한 사용자 에이전트에 대한 정보가 포함되어 있습니다. 이는 통계 목적, 프로토콜 위반 추적, 특정 사용자 에이전트 제한을 피하기 위한 맞춤형 응답을 위한 사용자 에이전트 자동 인식을 위한 것입니다. 필수는 아니지만 사용자 에이전트는 요청에 이 필드를 포함해야 합니다. 이 필드에는 여러 개의 제품 토큰<a href="#section-3.7">(섹션 3.7)</a>과 상담원 및 사용자 에이전트의 중요한 부분을 구성하는 하위 제품을 식별하는 댓글이 포함될 수 있습니다. 관례에 따라 제품 토큰은 애플리케이션을 식별하는 데 중요한 순서대로 나열됩니다. User-Agent = "사용자 에이전트" ":" 1*(제품 | 댓글 ) 예: 사용자 에이전트: CERN-LineMode/2.15 libwww/2.17b3 참고: 현재 일부 프록시 애플리케이션은 사용자-에이전트 필드에 있는 목록에 제품 정보를 추가합니다. 이는 이러한 필드의 기계 해석을 모호하게 만들기 때문에 권장되지 않습니다. 참고: 일부 기존 클라이언트는 사용자 에이전트 필드 내의 제품 토큰 구문으로 제한하지 않습니다.<span class="h3"><a class="selflink" href="#section-10.16" id="section-10.16">10.16</a> WWW-Authenticate</span>응답 헤더 필드는 401(권한이 없는) 응답 메시지에 포함되어야 합니다. 필드 값은 요청-URI에 적용되는 인증 체계와 매개변수를 나타내는 하나 이상의 챌린지로 구성됩니다. WWW-Authenticate = "WWW-Authenticate" ":" 1#챌린지 HTTP 액세스 인증 절차는 <a href="#section-11">섹션 11에</a> 설명되어 있습니다. 사용자 에이전트는 두 개 이상의 챌린지가 포함된 경우 또는 두 개 이상의 WWW-Authenticate 헤더 필드가 제공되는 경우 챌린지의 내용 자체가 쉼표로 구분된 인증 파라미터 목록을 포함할 수 있으므로 WWW-Authenticate 필드 값을 파싱할 때 특별히 주의해야 합니다.<span class="grey">버너스-리 외 정보 [46페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-47"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><span class="h2"><a class="selflink" href="#section-11" id="section-11">11</a>.  접근 인증</span>HTTP는 서버가 클라이언트 요청에 도전하고 클라이언트가 인증 정보를 제공하는 데 사용할 수 있는 간단한 챌린지-응답 인증 메커니즘을 제공합니다. 이 메커니즘은 대소문자를 구분하지 않는 확장 가능한 토큰을 사용하여 인증 체계를 식별한 다음, 해당 체계를 통해 인증을 수행하는 데 필요한 매개변수를 포함하는 쉼표로 구분된 속성-값 쌍의 목록을 사용합니다. auth-scheme = 토큰 auth-param = 토큰 "=" 따옴표- 문자열 401(권한 없음) 응답 메시지는 원본 서버에서 사용자 에이전트의 권한에 이의를 제기하는 데 사용됩니다. 이 응답에는 요청된 리소스에 적용되는 챌린지가 하나 이상 포함된 WWW-Authenticate 헤더 필드가 포함되어야 합니다. challenge = auth-scheme 1*SP 영역 *( "," auth-param ) 영역 = "영역" "=" 영역-값 영역-값 = 따옴표- 문자열 영역 속성(대소문자 구분)은 챌린지를 발급하는 모든 인증 체계에 필요합니다. 영역 값(대소문자 구분)은 액세스하는 서버의 표준 루트 URL과 함께 보호 공간을 정의합니다. 이러한 영역을 사용하면 서버의 보호된 리소스를 각각 고유한 인증 체계 및/또는 권한 부여 데이터베이스가 있는 일련의 보호 공간으로 분할할 수 있습니다. 영역 값은 일반적으로 원본 서버에서 할당하는 문자열로, 인증 체계와 관련된 추가 의미를 가질 수 있습니다. 일반적으로 401 응답을 받은 후 서버에서 자신을 인증하려는 사용자 에이전트는 요청에 권한 부여 헤더 필드를 포함하여 인증할 수 있습니다(반드시 그렇지는 않음). 권한 부여 필드 값은 요청되는 리소스의 영역에 대한 사용자 에이전트의 인증 정보가 포함된 자격 증명으로 구성됩니다. 자격 증명 = 기본 자격 증명 | ( auth-scheme #auth-param ) 사용자 에이전트가 자격 증명을 자동으로 적용할 수 있는 도메인은 보호 영역에 따라 결정됩니다. 이전 요청이 승인된 경우 해당 보호 공간 내의 다른 모든 요청에 동일한 자격 증명을 결정된 기간 동안 재사용할 수 있습니다(<span class="grey">Berners-Lee 외 정보 [47페이지]</span>).</pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-48"></span>
인증 체계, 매개변수 및/또는 사용자 기본 설정에 따라<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>. 인증 체계에서 달리 정의하지 않는 한, 단일 보호 공간은 서버의 범위를 벗어날 수 없습니다. 서버가 요청과 함께 전송된 자격 증명을 수락하지 않으려는 경우 403(금지됨) 응답을 반환해야 합니다. HTTP 프로토콜은 액세스 인증을 위해 이 단순한 챌린지-응답 메커니즘으로 애플리케이션을 제한하지 않습니다. 전송 수준에서의 암호화 또는 메시지 캡슐화를 통한 암호화, 인증 정보를 지정하는 추가 헤더 필드와 같은 추가 메커니즘을 사용할 수 있습니다. 그러나 이러한 추가 메커니즘은 이 사양에 정의되어 있지 않습니다. 프록시는 사용자 에이전트 인증과 관련하여 완전히 투명해야 합니다. 즉, 프록시는 WWW-Authenticate 및 Authorization 헤더를 그대로 전달해야 하며 Authorization이 포함된 요청에 대한 응답을 캐시해서는 안 됩니다. HTTP/1.0은 프록시로 클라이언트를 인증할 수 있는 수단을 제공하지 않습니다.<span class="h3"><a class="selflink" href="#section-11.1" id="section-11.1">11.1</a> 기본 인증 체계</span>"기본" 인증 체계는 사용자 에이전트가 각 영역마다 사용자 ID와 비밀번호로 자신을 인증해야 하는 모델을 기반으로 합니다. 영역 값은 해당 서버의 다른 영역과 동일성을 확인하기 위해서만 비교할 수 있는 불투명한 문자열로 간주해야 합니다. 서버는 요청-URI의 보호 공간에 대한 사용자 ID와 비밀번호의 유효성을 검사할 수 있는 경우에만 요청을 승인합니다. 선택적 인증 매개변수는 없습니다. 보호 공간 내에서 URI에 대한 무단 요청을 수신하면 서버는 다음과 같은 챌린지로 응답해야 합니다: WWW-Authenticate: 기본 영역="WallyWorld" 여기서 "WallyWorld"는 요청-URI의 보호 공간을 식별하기 위해 서버가 할당하는 문자열입니다. 인증을 받기 위해 클라이언트는 사용자 ID와 비밀번호를 하나의 콜론(":") 문자로 구분하여 자격증명에서 base64<a href="#ref-5" title='"MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies"'>[5</a>] 인코딩된 문자열로 보냅니다.
 기본 자격 증명 = "기본" SP 기본 쿠키 기본 쿠키 = &lt;base64<a href="#ref-5" title='"MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies"'>[5</a>] 인코딩(76자/행으로 제한되지 않음) 사용자 아이디-비밀번호&gt;<span class="grey">Berners-Lee 등 정보 [48페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-49"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>userid-password = [ 토큰 ] ":" *TEXT 사용자 에이전트가 사용자 ID "알라딘"과 비밀번호 "오픈세서미"를 보내려면 다음과 같은 헤더 필드를 사용합니다: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== 기본 인증 체계는 HTTP 서버의 리소스에 대한 무단 액세스를 필터링하는 비보안 방식입니다. 이는 클라이언트와 서버 간의 연결이 신뢰할 수 있는 통신사로 간주될 수 있다는 가정을 기반으로 합니다. 개방형 네트워크에서는 일반적으로 그렇지 않으므로 기본 인증 체계를 적절히 사용해야 합니다. 그럼에도 불구하고 클라이언트는 해당 체계를 사용하는 서버와 통신하기 위해 해당 체계를 구현해야 합니다<span class="h2">.</span><span class="h2">보안 고려 사항</span>이 섹션은 애플리케이션 개발자, 정보 제공자, 사용자에게 이 문서에서 설명하는 HTTP/1.0의 보안 제한 사항을 알리기 위한 것입니다. 이 논의에는 보안 위험을 줄이기 위한 몇 가지 제안이 포함되어 있지만, 드러난 문제에 대한 확실한 해결책은 포함되어 있지 않습니다.<span class="h3"><a class="selflink" href="#section-12.1" id="section-12.1">12.1</a> 클라이언트 인증</span> <a href="#section-11.1">섹션 11.1에서</a> 언급했듯이 기본 인증 체계는 안전한 사용자 인증 방법이 아니며, 통신사로 사용되는 물리적 네트워크를 통해 엔티티-바디가 평문으로 전송되는 것을 방지하지도 못합니다. HTTP/1.0은 보안을 강화하기 위해 추가적인 인증 체계와 암호화 메커니즘을 사용하는 것을 막지 않습니다.<span class="h3"><a class="selflink" href="#section-12.2" id="section-12.2">12.2</a> 안전한 방법</span>클라이언트 소프트웨어 작성자는 소프트웨어가 인터넷을 통한 상호작용에서 사용자를 대표한다는 점을 인식하고 사용자가 자신이나 타인에게 예기치 않은 영향을 미칠 수 있는 모든 행동을 인지할 수 있도록 주의해야 합니다. 특히 GET 및 HEAD 메서드는 검색 이외의 작업을 수행하는 데 의미가 없어야 한다는 관습이 확립되어 있습니다. 이러한 메서드는 "안전한" 것으로 간주되어야 합니다. 이를 통해 사용자 에이전트는 POST와 같은 다른 메서드를 특별한 방식으로 표현하여 사용자에게 안전하지 않을 수 있는 작업이 요청되고 있다는 사실을 알릴 수 있습니다.<span class="grey">버너스 리 등 정보 [49페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-50"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>당연히 서버가 GET 요청을 수행한 결과 부작용을 생성하지 않는다고 보장할 수는 없으며, 실제로 일부 동적 리소스는 이를 기능으로 간주합니다. 여기서 중요한 차이점은 사용자가 부작용을 요청한 것이 아니므로 이에 대한 책임을 물을 수 없다는 것입니다.<span class="h3"><a class="selflink" href="#section-12.3" id="section-12.3">12.3</a> 서버 로그 정보의 남용</span>서버는 사용자의 요청에 대한 개인 데이터를 저장할 수 있는 위치에 있으며, 이는 사용자의 읽기 패턴이나 관심 주제를 식별할 수 있습니다. 이 정보는 본질적으로 기밀 정보이며 특정 국가에서는 법에 따라 취급이 제한될 수 있습니다. HTTP 프로토콜을 사용하여 데이터를 제공하는 사람은 해당 자료가 게시된 결과로 식별 가능한 개인의 허가 없이 배포되지 않도록 할 책임이 있습니다.<span class="h3"><a class="selflink" href="#section-12.4" id="section-12.4">12.4</a> 민감한 정보의 전송</span>일반적인 데이터 전송 프로토콜과 마찬가지로 HTTP는 전송되는 데이터의 내용을 규제할 수 없으며, 특정 요청의 맥락 내에서 특정 정보의 민감도를 결정하는 선험적인 방법도 없습니다. 따라서 애플리케이션은 해당 정보 제공자에게 이 정보에 대한 통제권을 최대한 많이 제공해야 합니다. 이 맥락에서 세 가지 헤더 필드는 특별히 언급할 가치가 있습니다: 서버, 참조자, 발신자. 서버의 특정 소프트웨어 버전을 공개하면 서버 컴퓨터가 보안 취약점이 있는 것으로 알려진 소프트웨어에 대한 공격에 더 취약해질 수 있습니다. 구현자는 서버 헤더 필드를 구성 가능한 옵션으로 설정해야 합니다. 참조자 필드를 사용하면 읽기 패턴을 연구하고 역방향 링크를 그릴 수 있습니다. 매우 유용할 수 있지만 사용자 세부 정보가 리퍼러에 포함된 정보와 분리되지 않으면 이 기능이 남용될 수 있습니다. 개인 정보가 제거된 경우에도 참조인 필드에는 공개가 부적절한 비공개 문서의 URI가 표시될 수 있습니다. 보낸 사람 필드에서 전송되는 정보는 사용자의 개인정보 보호 또는 사이트의 보안 정책과 충돌할 수 있으므로 사용자가 해당 필드의 내용을 비활성화, 활성화 및 수정할 수 없는 상태에서 전송되어서는 안 됩니다. 사용자는 사용자 기본 설정 또는 애플리케이션 기본 구성 내에서 이 필드의 내용을 설정할 수 있어야 합니다. 필수 사항은 아니지만 사용자가 보낸 사람 및 참조인 정보 전송을 활성화 또는 비활성화할 수 있도록 편리한 토글 인터페이스를 제공하는 것이 좋습니다.<span class="grey">Berners-Lee 등 정보 [50페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-51"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><span class="h3"><a class="selflink" href="#section-12.5" id="section-12.5">12.5</a> 파일 및 경로 이름을 기반으로 한 공격</span>HTTP 원본 서버의 구현은 HTTP 요청이 반환하는 문서가 서버 관리자가 의도한 문서로만 제한되도록 주의를 기울여야 합니다. HTTP 서버가 HTTP URI를 파일 시스템 호출로 직접 변환하는 경우, 서버는 HTTP 클라이언트에 전달할 의도가 없는 파일을 제공하지 않도록 각별히 주의해야 합니다. 예를 들어 Unix, Microsoft Windows 및 기타 운영 체제는 경로 구성 요소로 '...'를 사용하여 현재 디렉터리 수준보다 상위의 디렉터리 수준을 나타냅니다. 이러한 시스템에서 HTTP 서버를 통해 액세스하도록 의도된 리소스 이외의 리소스에 대한 액세스를 허용하는 경우 HTTP 서버는 요청-URI에서 이러한 구성을 허용하지 않아야 합니다. 마찬가지로 접근 제어 파일, 구성 파일, 스크립트 코드 등 서버 내부에서만 참조하도록 의도된 파일은 민감한 정보를 포함할 수 있으므로 부적절한 검색으로부터 보호해야 합니다. 경험에 따르면 이러한 HTTP 서버 구현의 사소한 버그가 보안 위험으로 전환된 사례가 있습니다<span class="h2"><a class="selflink" href="#section-13" id="section-13">.</a></span><span class="h2">감사의</span>말 이 사양은 데이비드 H. 크로커가 <a href="./rfc822">RFC 822</a><a href="#ref-7" title='"Standard for the Format of ARPA Internet Text Messages"'>[7</a>]에 정의한 증강 BNF와 일반 구성을 많이 사용합니다. 마찬가지로, 이 명세서는 나다니엘 보렌스타인과 네드 프리드가 MIME에 대해 제공한 많은 정의를 재사용합니다<a href="#ref-5" title='"MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies"'>[5</a>]. 이 사양에 포함됨으로써 HTTP/1.0과 인터넷 메일 메시지 형식 간의 관계에 대한 과거의 혼란을 줄이는 데 도움이 되기를 바랍니다. HTTP 프로토콜은 지난 4년 동안 상당히 발전해 왔습니다. 이는 대규모의 활발한 개발자 커뮤니티, 즉 www-talk 메일링 리스트에 참여한 많은 사람들로부터 혜택을 받았으며, 이러한 커뮤니티는 HTTP와 월드와이드웹 전반의 성공에 가장 큰 책임이 있는 커뮤니티입니다. 마크 안드레센, 로버트 카일리아우, 다니엘 코놀리, 밥 데니, 장 프랑소와 그로프, 필립 M. 할람-베이커, 하콘 W. 라이, 아리 루오토넨, 롭 맥쿨, 루 몬툴리, 데이브 래겟, 토니 샌더스, 마크 반헤닝언은 이 사양의 초기 버전 프로토콜을 정의하는 데 기여한 공로로 특별히 인정받을 만합니다. 본 문서와 부록 C, D.<span class="grey">버너스 리 등의 정보 [51 페이지]</span> 섹션을 제공한 Paul Hoffman의 정보 상태 관련 내용</pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-52"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>이 문서는 HTTP-WG에 참여한 모든 분들의 의견으로부터 많은 도움을 받았습니다. 이미 언급된 분들 외에도 다음과 같은 분들이 이 사양에 기여했습니다: Gary Adams Harald Tveit Alvestrand Keith Ball Brian Behlendorf Paul Burchard Maurizio Codogno Mike Cowlishaw Roman Czyborra Michael A. Dolan John Franks Jim Gettys Marc Hedlund Koen Holtman Alex Hopmann Bob Jernigan Shel Kaphan Martijn Koster Dave Kristol Daniel LaLiberte Paul Leach Albert Lunde John C.. Mallery 래리 마신터 미트라 제프리 모굴 개빈 니콜 빌 페리 제프리 페리 오웬 리스 루이지 리조 데이비드 로빈슨 마크 살로몬 리치 살츠 짐 시드만 척 쇼튼 에릭 W. 싱크 사이먼 E. 스페로 로버트 S. 타우 프랑수아 예르고 메리 엘렌 주르코 장 필립 마틴-플라틴<span class="h2"><a class="selflink" href="#section-14" id="section-14">14</a>. 참고자료</span><a id="ref-1">[1</a>] Anklesaria, F., McCahill, M., Lindner, P., Johnson, D., Torrey, D., B. Alberti, "The Internet Gopher Protocol: 분산 문서 검색 및 검색 프로토콜", <a href="./rfc1436">RFC 1436</a>, 미네소타 대학교, 1993년 3월<a id="ref-2">[2</a>] Berners-Lee, T., "WWW의 범용 자원 식별자: 월드와이드웹에서 사용되는 네트워크 상의 객체 이름과 주소 표현을 위한 통일 구문", <a href="./rfc1630">RFC 1630</a>, CERN, 1994년 6월<a id="ref-3">[3</a>] Berners-Lee, T., and D. Connolly, "Hypertext Markup Language - 2.0", <a href="./rfc1866">RFC 1866</a>, MIT/W3C, 1995년 11월.<a id="ref-4">[4</a>] Berners-Lee, T., Masinter, L. 및 M. McCahill, "Uniform Resource Locators (URL)", <a href="./rfc1738">RFC 1738</a>, CERN, Xerox PARC, University of Minnesota, December 1994.<span class="grey">Berners-Lee 외 정보 [52페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-53"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><a id="ref-5">[5</a>] Borenstein, N., and N. Freed, "MIME (Multipurpose Internet Mail Extensions) 파트 1: 인터넷 메시지 본문의 형식을 지정하고 설명하는 메커니즘", <a href="./rfc1521">RFC 1521</a>, Bellcore, Innosoft, 1993년 9월<a id="ref-6">[6</a>] Braden, R., "인터넷 호스트에 대한 요구 사항 - 응용 및 지원", STD 3, <a href="./rfc1123">RFC 1123</a>, IETF, 1989년 10월.<a id="ref-7">[7</a>] Crocker, D., "ARPA 인터넷 문자 메시지 형식 표준", STD 11, <a href="./rfc822">RFC 822</a>, UDEL, 1982년 8월.<a id="ref-8">[8</a>] F. Davis, B. Kahle, H. Morris, J. Salem, T. Shen, R. Wang, J. Sui, and M. Grinbaum. "WAIS 인터페이스 프로토콜 프로토타입 기능 사양." (v1.5), Thinking Machines Corporation, 1990년 4월.<a id="ref-9">[9</a>] Fielding, R., "Relative Uniform Resource Locators", <a href="./rfc1808">RFC 1808</a>, UC Irvine, 1995년 6월.<a id="ref-10">[10</a>] Horton, M., and R. Adams, "Standard for interchange of USENET Messages", <a href="./rfc1036">RFC 1036</a> (Obsoletes <a href="./rfc850">RFC 850</a>), AT&amp;T Bell Laboratories, Center for Seismic Studies, 1987년 12월.<a id="ref-11">[11</a>] Kantor, B., and P. Lapsley, "Network News Transfer Protocol:  스트림 기반 뉴스 전송을 위한 제안된 표준", <a href="./rfc977">RFC 977</a>, UC 샌디에이고, UC 버클리, 1986년 2월.<a id="ref-12">[12</a>] Postel, J., "Simple Mail Transfer Protocol." STD 10, <a href="./rfc821">RFC 821</a>, USC/ISI, August 1982.<a id="ref-13">[13</a>] Postel, J., "미디어 유형 등록 절차." <a href="./rfc1590">RFC 1590</a>, USC/ISI, March 1994.<a id="ref-14">[14</a>] Postel, J., and J. Reynolds, "File Transfer Protocol (FTP)", STD 9, <a href="./rfc959">RFC 959</a>, USC/ISI, October 1985.<a id="ref-15">[15</a>] Reynolds, J., and J. Postel, "Assigned Numbers", STD 2, <a href="./rfc1700">RFC</a> <a href="./rfc1700">1700</a>, USC/ISI, October 1994.<a id="ref-16">[16</a>] Sollins, K., and L. Masinter, "Functional Requirements for Uniform Resource Names", <a href="./rfc1737">RFC 1737</a>, MIT/LCS, Xerox Corporation, December 1994.<a id="ref-17">[17</a>] US-ASCII. 코드화된 문자 집합 - 정보 교환을 위한 7비트 미국 표준 코드. 표준 ANSI X3.4-1986, ANSI, 1986.<span class="grey">버너스-리 외 정보 [53페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-54"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><a id="ref-18">[18</a>] ISO-8859. 국제 표준 -- 정보 처리 -- 8비트 단일 바이트 코딩 그래픽 문자 집합 -- 파트 1: 라틴 알파벳 1, ISO 8859-1:1987.  파트 2: 라틴 알파벳 2번, ISO 8859-2, 1987.  파트 3: 라틴 알파벳 3번, ISO 8859-3, 1988.  파트 4: 라틴 알파벳 4번, ISO 8859-4, 1988.  파트 5: 라틴/키릴 문자, ISO 8859-5, 1988.  파트 6: 라틴/아랍 알파벳, ISO 8859-6, 1987.  파트 7: 라틴/그리스 알파벳, ISO 8859-7, 1987.  파트 8: 라틴/히브리 알파벳, ISO 8859-8, 1988.  파트 9: 라틴 알파벳 5번, ISO 8859-9, 1990<span class="h2">.</span><span class="h2">저자 주소</span>팀 버너스-리 W3 컨소시엄 MIT 컴퓨터 과학 연구소 소장 545 Technology Square Cambridge, MA 02139, USA 팩스: +1 (617) 258 8682 이메일: timbl@w3.org 로이 필딩 정보 및 컴퓨터 과학부 캘리포니아 대학교 어바인, CA 92717-3425, U.S.A. 팩스: +1 (714) 824-4056 이메일: fielding@ics.uci.edu 헨릭 프리스틱 닐슨 W3 컨소시엄 MIT 컴퓨터 과학 연구소 545 Technology Square Cambridge, MA 02139, U.S.A. 팩스: +1 (617) 258 8682 이메일: frystyk@w3.org<span class="grey">버너스-리 외 정보 [54페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-55"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>부록 이 부록은 정보 제공 목적으로만 제공되며 HTTP/1.0 사양의 일부를 구성하지 않습니다.<span class="h2"><a class="selflink" href="#appendix-A" id="appendix-A">A</a>.  인터넷 미디어 유형 message/http</span>이 문서는 HTTP/1.0 프로토콜을 정의하는 것 외에도 인터넷 미디어 유형 "message/http"에 대한 사양으로 사용됩니다. 미디어 유형 이름: 메시지 미디어 하위 유형 이름: http 필수 파라미터: 없음 선택 파라미터: 버전, 메시지 유형 버전: 동봉된 메시지의 HTTP 버전 번호(예: "1.0"). 없는 경우 본문의 첫 줄에서 버전을 확인할 수 있습니다. msgtype: 메시지 유형 - "요청" 또는 "응답". 없는 경우 본문의 첫 줄에서 유형을 확인할 수 있습니다. 인코딩 고려 사항: "7비트", "8비트" 또는 "이진"만 허용됩니다. 보안 고려 사항: 없음<span class="h2"><a class="selflink" href="#appendix-B" id="appendix-B">B</a></span>.  내성<span class="h2">애플리케이션</span>이 문서는 HTTP/1.0 메시지 생성을 위한 요구 사항을 명시하고 있지만, 모든 애플리케이션이 이를 올바르게 구현하는 것은 아닙니다. 따라서 운영 중인 애플리케이션은 편차를 명확하게 해석할 수 있는 경우 편차를 허용하는 것이 좋습니다. 클라이언트는 상태 줄을 파싱할 때 편차를 허용해야 하고 서버는 요청 줄을 파싱할 때 편차를 허용해야 합니다. 특히, 필드 사이에 SP 또는 HT 문자가 하나만 필요하더라도 얼마든지 허용해야 합니다. HTTP 헤더 필드의 라인 종결자는 시퀀스 CRLF입니다. 그러나 애플리케이션은 이러한 헤더를 파싱할 때 단일 LF를 줄 종결자로 인식하고 선행 CR은 무시하는 것이 좋습니다.<span class="grey">버너스-리 외 정보 [55페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-56"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><span class="h2"><a class="selflink" href="#appendix-C" id="appendix-C">C</a>.  MIME과의 관계</span>HTTP/1.0은 인터넷 메일<a href="./rfc822">(RFC</a><ahref=". rfc822"="">822<a href="#ref-7" title='"Standard for the Format of ARPA Internet Text Messages"'>[7</a>])과 다목적 인터넷 메일 확장(MIME<a href="#ref-5" title='"MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies"'>[5</a>])에 정의된 많은 구성을 사용하여 엔티티가 개방적이고 다양한 표현과 확장 가능한 메커니즘으로 전송될 수 있도록 합니다. 그러나 <a href="./rfc1521">RFC 1521은</a> 메일에 대해 설명하며, HTTP에는 <a href="./rfc1521">RFC 1521에서</a> 설명하는 것과는 다른 몇 가지 기능이 있습니다. 이러한 차이점은 이진 연결에 대한 성능을 최적화하고, 새로운 미디어 유형을 보다 자유롭게 사용할 수 있도록 하며, 날짜 비교를 보다 쉽게 하고, 일부 초기 HTTP 서버와 클라이언트의 관행을 인정하기 위해 신중하게 선택되었습니다. 이 글을 쓰는 시점에서 <a href="./rfc1521">RFC 1521이</a> 개정될 것으로 예상됩니다. 개정안에는 HTTP/1.0에는 있지만 <a href="./rfc1521">RFC 1521에는</a> 없는 일부 관행이 포함될 수 있습니다. 이 부록에서는 HTTP가 <a href="./rfc1521">RFC</a><ahref=". rfc1521"="">1521과 다른 특정 영역에 대해 설명합니다. 엄격한 MIME 환경을 사용하는 프록시와 게이트웨이는 이러한 차이점을 인지하고 필요한 경우 적절한 변환을 제공해야 합니다. MIME 환경의 프록시와 게이트웨이가 HTTP로 변환하는 경우에도 일부 변환이 필요할 수 있으므로 차이점을 알고 있어야 합니다.<span class="h3"><a class="selflink" href="#appendix-C.1" id="appendix-C.1">C.1</a></span>표준<span class="h3">형식으로의 변환</span> <a href="./rfc1521">RFC 1521에서는</a> 인터넷 메일 개체를 전송하기 전에 <a href="./rfc1521#appendix-G">RFC 1521</a><a href="#ref-5" title='"MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies"'>[5</a>] <a href="./rfc1521#appendix-G">의 부록 G에</a> 설명된 대로 표준 형식으로 변환할 것을 요구합니다. 이 문서의 <a href="#section-3.6.1">3.6.1절에서는</a> HTTP를 통해 전송할 때 "텍스트" 미디어 유형의 하위 유형에 허용되는 형식을 설명합니다. <a href="./rfc1521">RFC 1521에서는</a> 콘텐츠 유형이 "텍스트"인 콘텐츠는 줄 바꿈을 CRLF로 표시해야 하며 줄 바꿈 시퀀스 외부에서 CR 또는 LF를 사용하는 것을 금지하고 있습니다. HTTP는 HTTP를 통해 메시지가 전송될 때 텍스트 콘텐츠 내에서 줄바꿈, 베어 CR, 베어 LF를 허용합니다. 가능한 경우, HTTP에서 엄격한 <a href="./rfc1521">RFC</a><ahref=". rfc1521"="">1521 환경으로의 프록시 또는 게이트웨이는 이 문서의 <a href="#section-3.6.1">섹션 3.6.1에</a> 설명된 텍스트 미디어 유형 내의 모든 줄바꿈들을 <a href="./rfc1521">RFC</a><ahref=". rfc1521"="">1521 표준 형식의 CRLF로 변환해야 합니다. 그러나 콘텐츠 인코딩의 존재와 일부 멀티바이트 문자 집합의 경우처럼 HTTP가 CR 및 LF를 표현하기 위해 옥텟 13과 10을 사용하지 않는 일부 문자 집합의 사용을 허용한다는 사실로 인해 이 작업이 복잡해질 수 있습니다.<span class="grey">버너스 리 외 정보 [56페이지]</span></ahref=".></ahref=".></ahref=".></ahref=".></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-57"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><span class="h3"><a class="selflink" href="#appendix-C.2" id="appendix-C.2">C.2</a> 날짜 형식의 변환</span>HTTP/1.0은 날짜 비교 프로세스를 단순화하기 위해 제한된 날짜 형식 집합<a href="#section-3.3">(섹션 3.3</a>)을 사용합니다. 다른 프로토콜의 프록시와 게이트웨이는 메시지에 존재하는 날짜 헤더 필드가 HTTP/1.0 형식 중 하나를 준수하는지 확인하고 필요한 경우 날짜를 다시 작성해야 합니다.<span class="h3"><a class="selflink" href="#appendix-C.3" id="appendix-C.3">C.3</a> 콘텐츠 인코딩 도입</span> <a href="./rfc1521">RFC 1521에는</a> HTTP/1.0의 콘텐츠 인코딩 헤더 필드에 해당하는 개념이 포함되어 있지 않습니다. 이는 미디어 타입에 대한 수정자 역할을 하므로, HTTP에서 MIME 호환 프로토콜로의 프록시 및 게이트웨이는 메시지를 전달하기 전에 Content-Type 헤더 필드 값을 변경하거나 Entity-Body를 디코딩해야 합니다. (인터넷 메일에 Content-Type을 실험적으로 적용한 일부 애플리케이션에서는 ";conversions=&lt;콘텐츠-코딩&gt;"의 미디어 유형 매개변수를 사용하여 Content-Encoding과 동등한 기능을 수행했습니다. 그러나 이 매개변수는 <a href="./rfc1521">RFC 1521의</a> 일부가 아닙니다.)<span class="h3"><a class="selflink" href="#appendix-C.4" id="appendix-C.4">C.4</a> 콘텐츠 전송 인코딩 없음</span>HTTP는 <a href="./rfc1521">RFC</a><ahref=". rfc1521"="">1521의 콘텐츠 전송 인코딩(CTE) 필드를 사용하지 않습니다. MIME 호환 프로토콜에서 HTTP로 전송하는 프록시 및 게이트웨이는 응답 메시지를 HTTP 클라이언트에 전달하기 전에 비식별 CTE("따옴표-인쇄 가능" 또는 "base64") 인코딩을 제거해야 합니다. HTTP에서 MIME 호환 프로토콜로 전송하는 프록시 및 게이트웨이는 해당 프로토콜에서 안전한 전송을 위해 메시지가 올바른 형식과 인코딩인지 확인하고 '안전한 전송'은 사용 중인 프로토콜의 제한에 따라 정의됩니다. 이러한 프록시 또는 게이트웨이는 대상 프로토콜을 통한 안전한 전송 가능성을 높일 수 있는 경우 적절한 Content-Transfer-Encoding으로 데이터에 라벨을 지정해야 합니다.<span class="h3"><a class="selflink" href="#appendix-C.5" id="appendix-C.5">C.5</a> 멀티파트 본문 파트의 HTTP 헤더 필드</span> <a href="./rfc1521">RFC 1521에서</a> 멀티파트 본문 파트의 대부분의 헤더 필드는 일반적으로 필드 이름이 "Content-"로 시작하지 않으면 무시됩니다. HTTP/1.0에서 멀티파트 본문-파트는 해당 파트의 의미에 중요한 모든 HTTP 헤더 필드를 포함할 수 있습니다.<span class="h2"><a class="selflink" href="#appendix-D" id="appendix-D">D</a>.  추가 기능</span>이 부록은 일부 기존 HTTP 구현에서 사용되지만 대부분의 HTTP/1.0 애플리케이션에서 일관되고 올바르게 사용되지는 않는 프로토콜 요소를 문서화합니다. 구현자는 이러한 기능을 알고 있어야 하지만, 이러한 기능의 존재 또는 상호 운용성에 의존해서는 안 됩니다.<span class="grey">Berners-Lee 등 정보 [57 페이지]&lt;</span>/ahref=".&gt;&lt;/pre&gt;</ahref=".></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-58"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>, 기타 HTTP/1.0 애플리케이션<span class="h3"><a class="selflink" href="#appendix-D.1" id="appendix-D.1">D.1</a> 추가 요청 메서드</span><span class="h4"><a class="selflink" href="#appendix-D.1.1" id="appendix-D.1.1">D.1.1</a> PUT</span>PUT 메서드는 제공된 Request-URI 아래에 엔티티를 저장하도록 요청합니다. 요청-URI가 이미 존재하는 리소스를 참조하는 경우, 동봉된 엔티티는 원본 서버에 있는 엔티티의 수정된 버전으로 간주해야 합니다. 요청-URI가 기존 리소스를 가리키지 않고 요청하는 사용자 에이전트가 해당 URI를 새 리소스로 정의할 수 있는 경우 원본 서버는 해당 URI로 리소스를 만들 수 있습니다. POST와 PUT 요청의 근본적인 차이점은 요청-URI의 다른 의미에 반영되어 있습니다. POST 요청의 URI는 처리할 데이터로 묶인 엔티티를 처리할 리소스를 식별합니다. 해당 리소스는 데이터를 수락하는 프로세스, 다른 프로토콜의 게이트웨이 또는 주석을 수락하는 별도의 엔티티일 수 있습니다. 이와 대조적으로 PUT 요청의 URI는 요청에 포함된 엔티티를 식별합니다. 사용자 에이전트는 어떤 URI가 의도된 것인지 알고 있으며 서버는 요청을 다른 리소스에 적용해서는 안 됩니다.<span class="h4"><a class="selflink" href="#appendix-D.1.2" id="appendix-D.1.2">D.1.2</a> DELETE</span>DELETE 메서드는 원본 서버가 요청-URI로 식별된 리소스를 삭제하도록 요청합니다.<span class="h4"><a class="selflink" href="#appendix-D.1.3" id="appendix-D.1.3">D.1..3</a> LINK</span>메서드는 요청-URI로 식별된 기존 리소스와 다른 기존 리소스 간에 하나 이상의 링크 관계를 설정합니다.<span class="h4"><a class="selflink" href="#appendix-D.1.4" id="appendix-D.1.4">D.1.4</a> UN</span>LINK 메서드는 요청-URI로 식별된 기존 리소스에서 하나 이상의 링크 관계를 제거합니다. D.<span class="h3"><a class="selflink" href="#appendix-D.2" id="appendix-D.2">2</a> 추가 헤더 필드 정의</span><span class="h4"><a class="selflink" href="#appendix-D.2.1" id="appendix-D.2.1">D.2.1</a> Accept</span>요청-헤더 필드에 요청에 대한 응답으로 허용되는 미디어 범위 목록을 표시하는 데 사용할 수 있습니다. 별표 "*" 문자는 미디어 유형을 범위로 그룹화하는 데 사용되며, "*/*"는 모든 미디어 유형을 나타내고 "type/*"는 모든 하위 유형을 나타냅니다<span class="grey">Berners-Lee 외 정보 [58페이지]</span></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-59"></span>
해당 유형의<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span>. 클라이언트가 제공하는 범위 집합은 요청의 컨텍스트에 따라 허용되는 유형을 나타내야 합니다.<span class="h4"><a class="selflink" href="#appendix-D.2.2" id="appendix-D.2.2">D.2.2</a> Accept-Charset</span>Accept-Charset 요청 헤더 필드는 기본 US-ASCII 및 ISO-8859-1 이외의 선호 문자 집합 목록을 나타내는 데 사용할 수 있습니다. 이 필드를 사용하면 보다 포괄적이거나 특수 목적의 문자 집합을 이해할 수 있는 클라이언트가 해당 문자 집합으로 문서를 표현할 수 있는 서버에 해당 기능을 알릴 수 있습니다.<span class="h4"><a class="selflink" href="#appendix-D.2.3" id="appendix-D.2.3">D.2.3</a> Accept</span>-Encoding Accept-Encoding 요청 헤더 필드는 Accept와 유사하지만 응답에서 허용되는 콘텐츠 코딩 값을 제한합니다.<span class="h4"><a class="selflink" href="#appendix-D.2.4" id="appendix-D.2.4">D.2.4</a> Accept</span>-Language Accept-Language 요청 헤더 필드는 Accept와 유사하지만 요청에 대한 응답으로 선호되는 자연어 집합을 제한합니다.<span class="h4"><a class="selflink" href="#appendix-D.2.5" id="appendix-D.2.5">D.2.5</a> Content</span>-Language 엔티티 헤더 필드는 동봉된 엔티티에 대한 대상의 자연어를 설명합니다. 이 언어는 엔티티 내에서 사용되는 모든 언어와 동일하지 않을 수 있습니다.<span class="h4"><a class="selflink" href="#appendix-D.2.6" id="appendix-D.2.6">D.2.6</a> 링크</span>링크 엔티티 헤더 필드는 엔티티와 다른 리소스 간의 관계를 설명하는 수단을 제공합니다. 엔티티에는 여러 개의 링크 값이 포함될 수 있습니다. 메타정보 수준에서의 링크는 일반적으로 계층 구조 및 탐색 경로와 같은 관계를 나타냅니다.<span class="h4"><a class="selflink" href="#appendix-D.2.7" id="appendix-D.2.7">D.2.7</a> MIME-Version</span>HTTP 메시지에는 메시지를 구성하는 데 사용된 MIME 프로토콜 버전을 나타내는 단일 MIME-Version 일반 헤더 필드가 포함될 수 있습니다. <a href="./rfc1521">RFC</a><ahref=". rfc1521"="">1521<a href="#ref-5" title='"MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies"'>[5</a>]에 정의된 대로 MIME-Version 헤더 필드를 사용하면 메시지가 MIME 규격을 준수함을 표시해야 합니다. 안타깝게도 일부 구형 HTTP/1.0 서버는 이 필드를 무분별하게 전송하므로 이 필드는 무시해야 합니다.<span class="grey">Berners-Lee 등 정보 [59페이지]&lt;</span>/ahref=".&gt;&lt;/pre&gt;</ahref=".></pre>
<hr class="noprint" /><!--NewPage--><pre class="newpage"><span id="page-60"></span>
<span class="grey"><a href="./rfc1945">RFC 1945</a> HTTP/1.0 1996년 5월</span><span class="h4"><a class="selflink" href="#appendix-D.2.8" id="appendix-D.2.8">D.2.8</a> Retry-After</span>응답-헤더 필드는 503(서비스 사용 불가) 응답과 함께 사용하여 요청 클라이언트가 서비스를 사용할 수 없을 것으로 예상되는 시간을 나타낼 수 있습니다. 이 필드의 값은 응답 시간 이후 HTTP 날짜 또는 정수(십진수)일 수 있습니다.<span class="h4"><a class="selflink" href="#appendix-D.2.9" id="appendix-D.2.9">D.2.9</a> 제목</span>제목 엔티티 헤더 필드는 엔티티의 제목을 나타냅니다.<span class="h4"><a class="selflink" href="#appendix-D.2.10" id="appendix-D.2.10">D.2.10</a> U</span>RI URI 엔티티 헤더 필드에는 요청-URI 자원을 식별할 수 있는 통일 자원 식별자<a href="#section-3.2">(섹션 3.2)</a>의 일부 또는 전체가 포함될 수 있습니다. 지정된 URI를 사용하여 리소스에 액세스할 수 있다는 보장은 없습니다. 버너스-리 외 정보 [페이지 60]</pre>
</body>